
# When this file is updated in an existing source tree, it gets re-applied
# during the next build using "patch -N --fuzz=0", which ignores patches
# that have already been applied.  However, if a gdb file has been modified
# multiple times, the subsequent patching may fail to recognize that a
# given patch has been previously applied, and will attempt to re-apply it.
# To prevent any uninintended consequences, this file also acts as a
# shell script that can restore any gdb file to its original state prior
# to all subsequent patch applications.

tar xvzmf gdb-10.2.tar.gz \
	gdb-10.2/gdb/symtab.c \
	gdb-10.2/gdb/printcmd.c \
	gdb-10.2/gdb/symfile.c \
	gdb-10.2/gdb/Makefile.in

exit 0

--- gdb-10.2/Makefile.in.orig
+++ gdb-10.2/Makefile.in
@@ -340,6 +340,9 @@ AR_FOR_BUILD = @AR_FOR_BUILD@
 AS_FOR_BUILD = @AS_FOR_BUILD@
 CC_FOR_BUILD = @CC_FOR_BUILD@
 CFLAGS_FOR_BUILD = @CFLAGS_FOR_BUILD@
+ifeq (${CRASH_TARGET}, PPC64)
+CFLAGS_FOR_BUILD += -m64 -fPIC
+endif
 CXXFLAGS_FOR_BUILD = @CXXFLAGS_FOR_BUILD@
 CXX_FOR_BUILD = @CXX_FOR_BUILD@
 DLLTOOL_FOR_BUILD = @DLLTOOL_FOR_BUILD@
@@ -406,6 +409,9 @@ GNATBIND = @GNATBIND@
 GNATMAKE = @GNATMAKE@
 
 CFLAGS = @CFLAGS@
+ifeq (${CRASH_TARGET}, PPC64)
+CFLAGS += -m64 -fPIC
+endif
 LDFLAGS = @LDFLAGS@
 LIBCFLAGS = $(CFLAGS)
 CXXFLAGS = @CXXFLAGS@
--- gdb-10.2/gdb/Makefile.in.orig
+++ gdb-10.2/gdb/Makefile.in
@@ -571,7 +571,7 @@ CONFIG_DEP_SUBDIR = $(addsuffix /$(DEPDIR),$(CONFIG_SRC_SUBDIR))
 # It is also possible that you will need to add -I/usr/include/sys if
 # your system doesn't have fcntl.h in /usr/include (which is where it
 # should be according to Posix).
-DEFS = @DEFS@
+DEFS = -DCRASH_MERGE @DEFS@
 GDB_CFLAGS = -I. -I$(srcdir) -I$(srcdir)/config \
 	-DLOCALEDIR="\"$(localedir)\"" $(DEFS)
 
@@ -1135,6 +1135,7 @@ COMMON_SFILES = \
 	symmisc.c \
 	symtab.c \
 	target.c \
+	../../crash_target.c \
 	target-connection.c \
 	target-dcache.c \
 	target-descriptions.c \
@@ -1564,7 +1565,7 @@ COMMON_OBS = $(DEPFILES) $(CONFIG_OBS) $(YYOBJ) \
 	$(SUBDIR_TARGET_OBS) \
 	$(SUBDIR_GCC_COMPILE_OBS)
 
-SUBDIRS = doc @subdirs@ data-directory
+SUBDIRS = build_no_subdirs
 CLEANDIRS = $(SUBDIRS)
 
 # List of subdirectories in the build tree that must exist.
@@ -1606,8 +1607,8 @@ generated_files = \
 # Flags needed to compile Python code
 PYTHON_CFLAGS = @PYTHON_CFLAGS@
 
-all: gdb$(EXEEXT) $(CONFIG_ALL) gdb-gdb.py gdb-gdb.gdb
-	@$(MAKE) $(FLAGS_TO_PASS) DO=all "DODIRS=`echo $(SUBDIRS) | sed 's/testsuite//'`" subdir_do
+all: gdb$(EXEEXT) gdb-gdb.py gdb-gdb.gdb
+	@$(MAKE) -s $(FLAGS_TO_PASS) DO=all "DODIRS=`echo $(SUBDIRS) | sed 's/testsuite//'`" subdir_do
 
 # Rule for compiling .c files in the top-level gdb directory.
 # The order-only dependencies ensure that we create the build subdirectories.
@@ -1864,9 +1865,10 @@ libgdb.a: $(LIBGDB_OBS)
 # Removing the old gdb first works better if it is running, at least on SunOS.
 gdb$(EXEEXT): gdb.o $(LIBGDB_OBS) $(CDEPS) $(TDEPLIBS)
 	$(SILENCE) rm -f gdb$(EXEEXT)
+	@(cd ../..; make --no-print-directory GDB_FLAGS=-DGDB_10_2 library)
 	$(ECHO_CXXLD) $(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
-		-o gdb$(EXEEXT) gdb.o $(LIBGDB_OBS) \
-		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+                -o $(shell /bin/cat mergeobj) $(LIBGDB_OBS) \
+                $(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES) $(shell /bin/cat mergelibs)
 ifneq ($(CODESIGN_CERT),)
 	$(ECHO_SIGN) $(CODESIGN) -s $(CODESIGN_CERT) gdb$(EXEEXT)
 endif
@@ -2530,9 +2532,9 @@ ifeq ($(DEPMODE),depmode=gcc3)
 # into place if the compile succeeds.  We need this because gcc does
 # not atomically write the dependency output file.
 override COMPILE.post = -c -o $@ -MT $@ -MMD -MP \
-	-MF $(@D)/$(DEPDIR)/$(basename $(@F)).Tpo
-override POSTCOMPILE = @mv $(@D)/$(DEPDIR)/$(basename $(@F)).Tpo \
-	$(@D)/$(DEPDIR)/$(basename $(@F)).Po
+        -MF $(subst ../..,.,$(@D))/$(DEPDIR)/$(basename $(@F)).Tpo
+override POSTCOMPILE = @mv $(subst ../..,.,$(@D))/$(DEPDIR)/$(basename $(@F)).Tpo \
+        $(subst ../..,.,$(@D))/$(DEPDIR)/$(basename $(@F)).Po
 else
 override COMPILE.pre = source='$<' object='$@' libtool=no \
 	DEPDIR=$(DEPDIR) $(DEPMODE) $(depcomp) \
--- gdb-10.2/gdb/cli/cli-cmds.c.orig
+++ gdb-10.2/gdb/cli/cli-cmds.c
@@ -435,6 +435,11 @@ complete_command (const char *arg, int from_tty)
     }
 }
 
+#ifdef CRASH_MERGE
+static int crash_from_tty = 0;
+extern "C" void untrusted_file(FILE *, char *);
+#endif
+
 int
 is_complete_command (struct cmd_list_element *c)
 {
@@ -654,8 +659,32 @@ find_and_open_script (const char *script_file, int search_path)
       close (fd);
       errno = save_errno;
     }
-  else
-    opened.emplace (gdb_file_up (result), std::move (full_path));
+#ifdef CRASH_MERGE
+  /*
+   * Only allow trusted versions of .gdbinit files to be
+   * sourced during session initialization.
+   */
+  if (crash_from_tty == -1)
+    {
+      struct stat statbuf;
+      FILE *stream = result;
+      int _fd = fileno (stream);
+      if (fstat (_fd, &statbuf) < 0)
+        {
+          perror_with_name (full_path.get());
+          fclose (stream);
+          return opened;
+        }
+      if (statbuf.st_uid != getuid () || (statbuf.st_mode & S_IWOTH))
+        {
+          untrusted_file(NULL, full_path.get());
+          fclose (stream);
+          return opened;
+        }
+    }
+#endif
+  opened.emplace (gdb_file_up (result), std::move (full_path));
+
 
   return opened;
 }
@@ -719,7 +748,11 @@ source_script_with_search (const char *file, int from_tty, int search_path)
          If the source command was invoked interactively, throw an
 	 error.  Otherwise (e.g. if it was invoked by a script),
 	 just emit a warning, rather than cause an error.  */
+#ifdef CRASH_MERGE
+      if (from_tty > 0)
+#else
       if (from_tty)
+#endif
 	perror_with_name (file);
       else
 	{
@@ -743,7 +776,14 @@ source_script_with_search (const char *file, int from_tty, int search_path)
 void
 source_script (const char *file, int from_tty)
 {
+#ifdef CRASH_MERGE
+  crash_from_tty = from_tty;
+#endif
   source_script_with_search (file, from_tty, 0);
+#ifdef CRASH_MERGE
+  crash_from_tty = 0;
+#endif
+
 }
 
 static void
--- gdb-10.2/gdb/defs.h.orig
+++ gdb-10.2/gdb/defs.h
@@ -629,4 +629,7 @@ DEF_ENUM_FLAGS_TYPE (enum user_selected_what_flag, user_selected_what);
 
 #include "utils.h"
 
+#ifdef CRASH_MERGE
+extern "C" int gdb_main_entry(int, char **);
+#endif
 #endif /* #ifndef DEFS_H */
--- gdb-10.2/gdb/dwarf2/read.c.orig
+++ gdb-10.2/gdb/dwarf2/read.c
@@ -3015,7 +3015,11 @@ read_gdb_index_from_buffer (const char *filename,
      indices.  */
   if (version < 4)
     {
+#ifdef CRASH_MERGE
+      static int warning_printed = 1;
+#else
       static int warning_printed = 0;
+#endif
       if (!warning_printed)
 	{
 	  warning (_("Skipping obsolete .gdb_index section in %s."),
@@ -3034,7 +3038,11 @@ read_gdb_index_from_buffer (const char *filename,
      "set use-deprecated-index-sections on".  */
   if (version < 6 && !deprecated_ok)
     {
+#ifdef CRASH_MERGE
+      static int warning_printed = 1;
+#else
       static int warning_printed = 0;
+#endif
       if (!warning_printed)
 	{
 	  warning (_("\
--- gdb-10.2/gdb/main.c.orig
+++ gdb-10.2/gdb/main.c
@@ -392,6 +392,14 @@ start_event_loop ()
   return;
 }
 
+#ifdef CRASH_MERGE
+extern "C" void update_gdb_hooks(void);
+extern "C" void main_loop(void);
+extern "C" unsigned long crash_get_kaslr_offset(void);
+extern "C" int console(const char *, ...);
+void crash_target_init (void);
+#endif
+
 /* Call command_loop.  */
 
 /* Prevent inlining this function for the benefit of GDB's selftests
@@ -925,7 +933,11 @@ captured_main_1 (struct captured_main_args *context)
       }
   }
 
+#ifdef CRASH_MERGE
+  save_original_signals_state (1);
+#else
   save_original_signals_state (quiet);
+#endif
 
   /* Try to set up an alternate signal stack for SIGSEGV handlers.  */
   gdb::alternate_signal_stack signal_stack;
@@ -999,7 +1011,7 @@ captured_main_1 (struct captured_main_args *context)
     {
       print_gdb_version (gdb_stdout, false);
       wrap_here ("");
-      printf_filtered ("\n");
+      printf_filtered ("\n\n");
       exit (0);
     }
 
@@ -1038,6 +1050,10 @@ captured_main_1 (struct captured_main_args *context)
      look at things by now.  Initialize the default interpreter.  */
   set_top_level_interpreter (interpreter_p);
 
+#ifdef CRASH_MERGE
+  update_gdb_hooks();
+#endif
+
   /* FIXME: cagney/2003-02-03: The big hack (part 2 of 2) that lets
      GDB retain the old MI1 interpreter startup behavior.  Output the
      copyright message after the interpreter is installed when it is
@@ -1066,7 +1082,11 @@ captured_main_1 (struct captured_main_args *context)
   if (!system_gdbinit.empty () && !inhibit_gdbinit)
     {
       for (const std::string &file : system_gdbinit)
+#ifdef CRASH_MERGE
+        ret = catch_command_errors (source_script, file.c_str (), -1);
+#else
 	ret = catch_command_errors (source_script, file.c_str (), 0);
+#endif
     }
 
   /* Read and execute $HOME/.gdbinit file, if it exists.  This is done
@@ -1075,7 +1095,11 @@ captured_main_1 (struct captured_main_args *context)
      debugging or what directory you are in.  */
 
   if (!home_gdbinit.empty () && !inhibit_gdbinit && !inhibit_home_gdbinit)
+#ifdef CRASH_MERGE
+    ret = catch_command_errors (source_script, home_gdbinit.c_str (), -1);
+#else
     ret = catch_command_errors (source_script, home_gdbinit.c_str (), 0);
+#endif
 
   /* Process '-ix' and '-iex' options early.  */
   for (i = 0; i < cmdarg_vec.size (); i++)
@@ -1121,7 +1145,11 @@ captured_main_1 (struct captured_main_args *context)
 				  !batch_flag);
       if (ret != 0)
 	ret = catch_command_errors (symbol_file_add_main_adapter,
+#ifdef CRASH_MERGE
+                                    symarg, 0);
+#else
 				    symarg, !batch_flag);
+#endif
     }
   else
     {
@@ -1191,7 +1219,11 @@ captured_main_1 (struct captured_main_args *context)
 	{
 	  auto_load_local_gdbinit_loaded = 1;
 
+#ifdef CRASH_MERGE
+          ret = catch_command_errors (source_script, local_gdbinit.c_str (), -1);
+#else
 	  ret = catch_command_errors (source_script, local_gdbinit.c_str (), 0);
+#endif
 	}
     }
 
@@ -1242,6 +1274,16 @@ captured_main (void *data)
 
   captured_main_1 (context);
 
+#ifdef CRASH_MERGE
+  /* Relocate the vmlinux. */
+  objfile_rebase (symfile_objfile, crash_get_kaslr_offset());
+
+  crash_target_init();
+
+  /* Back to crash.  */
+  main_loop();
+#endif
+
   /* NOTE: cagney/1999-11-07: There is probably no reason for not
      moving this loop and the code found in captured_command_loop()
      into the command_loop() proper.  The main thing holding back that
@@ -1256,6 +1298,9 @@ captured_main (void *data)
 	{
 	  exception_print (gdb_stderr, ex);
 	}
+#ifdef CRASH_MERGE
+        console("<CAPTURED_MAIN WHILE LOOP>\n");
+#endif
     }
   /* No exit -- exit is through quit_command.  */
 }
@@ -1277,6 +1322,22 @@ gdb_main (struct captured_main_args *args)
   return 1;
 }
 
+#ifdef CRASH_MERGE
+/*
+ *  NOTE: adapted from gdb.c, which is no longer built in; changed name of
+ *        original main() to gdb_main_entry() for use as crash entry point
+ */
+int
+gdb_main_entry (int argc, char **argv)
+{
+  struct captured_main_args args;
+  memset (&args, 0, sizeof args);
+  args.argc = argc;
+  args.argv = argv;
+  args.interpreter_p = INTERP_CONSOLE;
+  return gdb_main (&args);
+}
+#endif
 
 /* Don't use *_filtered for printing help.  We don't want to prompt
    for continue no matter how small the screen or how much we're going
--- gdb-10.2/gdb/objfiles.h.orig
+++ gdb-10.2/gdb/objfiles.h
@@ -747,9 +747,9 @@ extern int objfile_has_full_symbols (struct objfile *objfile);
 
 extern int objfile_has_symbols (struct objfile *objfile);
 
-extern int have_partial_symbols (void);
+extern "C" int have_partial_symbols (void);
 
-extern int have_full_symbols (void);
+extern "C" int have_full_symbols (void);
 
 extern void objfile_set_sym_fns (struct objfile *objfile,
 				 const struct sym_fns *sf);
--- gdb-10.2/gdb/printcmd.c.orig
+++ gdb-10.2/gdb/printcmd.c
@@ -524,6 +524,9 @@ set_next_address (struct gdbarch *gdbarch, CORE_ADDR addr)
    form.  However note that DO_DEMANGLE can be overridden by the specific
    settings of the demangle and asm_demangle variables.  Returns
    non-zero if anything was printed; zero otherwise.  */
+#ifdef CRASH_MERGE
+extern "C" int gdb_print_callback(unsigned long);
+#endif
 
 int
 print_address_symbolic (struct gdbarch *gdbarch, CORE_ADDR addr,
@@ -535,6 +538,12 @@ print_address_symbolic (struct gdbarch *gdbarch, CORE_ADDR addr,
   int offset = 0;
   int line = 0;
 
+#ifdef CRASH_MERGE
+  if (!gdb_print_callback(addr)) {
+        return 0;
+  }
+#endif
+
   if (build_address_symbolic (gdbarch, addr, do_demangle, false, &name,
                               &offset, &filename, &line, &unmapped))
     return 0;
@@ -1221,6 +1230,43 @@ print_command_1 (const char *args, int voidprint)
     print_value (val, print_opts);
 }
 
+static void
+print_command_2 (const char *args, int voidprint)
+{
+  struct value *val;
+  value_print_options print_opts;
+
+  get_user_print_options (&print_opts);
+  /* Override global settings with explicit options, if any.  */
+  auto group = make_value_print_options_def_group (&print_opts);
+  gdb::option::process_options
+    (&args, gdb::option::PROCESS_OPTIONS_REQUIRE_DELIMITER, group);
+
+  print_command_parse_format (&args, "print", &print_opts);
+
+  const char *exp = args;
+
+  if (exp != nullptr && *exp)
+    {
+      expression_up expr = parse_expression (exp);
+      val = evaluate_expression (expr.get ());
+    }
+  else
+    val = access_value_history (0);
+
+    printf_filtered ("%d %d %ld %ld %ld %ld\n",
+      check_typedef(value_type (val))->code(),
+      TYPE_UNSIGNED (check_typedef(value_type (val))),
+      TYPE_LENGTH (check_typedef(value_type(val))),
+      value_offset (val), value_bitpos (val), value_bitsize(val));
+}
+
+static void
+printm_command (const char *exp, int from_tty)
+{
+  print_command_2 (exp, 1);
+}
+
 /* See valprint.h.  */
 
 void
@@ -2855,6 +2901,12 @@ but no count or size letter (see \"x\" command)."),
   c = add_com ("print", class_vars, print_command, print_help.c_str ());
   set_cmd_completer_handle_brkchars (c, print_command_completer);
   add_com_alias ("p", "print", class_vars, 1);
+
+  c = add_com ("printm", class_vars, printm_command, _("\
+Similar to \"print\" command, but it used to print the type, size, offset,\n\
+bitpos and bitsize of the expression EXP."));
+  set_cmd_completer (c, expression_completer);
+
   add_com_alias ("inspect", "print", class_vars, 1);
 
   add_setshow_uinteger_cmd ("max-symbolic-offset", no_class,
--- gdb-10.2/gdb/psymtab.c.orig
+++ gdb-10.2/gdb/psymtab.c
@@ -283,6 +283,9 @@ find_pc_sect_psymtab_closer (struct objfile *objfile,
   return best_pst;
 }

+#ifdef CRASH_MERGE
+  extern "C" int gdb_line_number_callback(unsigned long, unsigned long, unsigned long);
+#endif
 /* Find which partial symtab contains PC and SECTION.  Return NULL if
    none.  We return the psymtab that contains a symbol whose address
    exactly matches PC, or, if we cannot find an exact match, the
@@ -363,7 +366,12 @@ find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,

 	best_pst = find_pc_sect_psymtab_closer (objfile, pc, section, pst,
 						msymbol);
+#ifdef CRASH_MERGE
+        if ((best_pst != NULL) &&
+          gdb_line_number_callback(pc, pst->text_low (objfile), pst->text_high (objfile)))
+#else
 	if (best_pst != NULL)
+#endif
 	  return best_pst;
       }

--- gdb-10.2/gdb/symfile.c.orig
+++ gdb-10.2/gdb/symfile.c
@@ -652,7 +652,26 @@ default_symfile_offsets (struct objfile *objfile,
       for (cur_sec = abfd->sections; cur_sec != NULL; cur_sec = cur_sec->next)
 	/* We do not expect this to happen; just skip this step if the
 	   relocatable file has a section with an assigned VMA.  */
-	if (bfd_section_vma (cur_sec) != 0)
+        if (bfd_section_vma (cur_sec) != 0
+           /*
+            *  Kernel modules may have some non-zero VMAs, i.e., like the
+            *  __ksymtab and __ksymtab_gpl sections in this example:
+            *
+            *    Section Headers:
+            *      [Nr] Name              Type             Address           Offset
+            *           Size              EntSize          Flags  Link  Info  Align
+            *      ...
+            *      [ 8] __ksymtab         PROGBITS         0000000000000060  0000ad90
+            *           0000000000000010  0000000000000000   A       0     0     16
+            *      [ 9] .rela__ksymtab    RELA             0000000000000000  0000ada0
+            *           0000000000000030  0000000000000018          43     8     8
+            *      [10] __ksymtab_gpl     PROGBITS         0000000000000070  0000add0
+            *           00000000000001a0  0000000000000000   A       0     0     16
+            *      ...
+            *
+            *  but they should be treated as if they are NULL.
+            */
+            && strncmp (bfd_section_name (cur_sec), "__k", 3) != 0)
 	  break;
 
       if (cur_sec == NULL)
@@ -1083,6 +1102,12 @@ symbol_file_add_with_addrs (bfd *abfd, const char *name,
   if (mainline)
     flags |= OBJF_MAINLINE;
   objfile = objfile::make (abfd, name, flags, parent);
+#ifdef CRASH_MERGE
+  if (add_flags & SYMFILE_MAINLINE) {
+    extern struct objfile *gdb_kernel_objfile;
+    gdb_kernel_objfile = objfile;
+  }
+#endif
 
   /* We either created a new mapped symbol table, mapped an existing
      symbol table file which has not had initial symbol reading
@@ -1375,6 +1400,10 @@ show_debug_file_directory (struct ui_file *file, int from_tty,
 #if ! defined (DEBUG_SUBDIRECTORY)
 #define DEBUG_SUBDIRECTORY ".debug"
 #endif
+#ifdef CRASH_MERGE
+extern "C" int check_specified_module_tree(const char *, const char *);
+extern "C" char *check_specified_kernel_debug_file();
+#endif
 
 /* Find a separate debuginfo file for OBJFILE, using DIR as the directory
    where the original file resides (may not be the same as
@@ -1410,6 +1439,15 @@ find_separate_debug_file (const char *dir,
   if (separate_debug_file_exists (debugfile, crc32, objfile))
     return debugfile;
 
+#ifdef CRASH_MERGE
+{
+  if (check_specified_module_tree(objfile_name (objfile), debugfile.c_str()) &&
+      separate_debug_file_exists(debugfile, crc32, objfile)) {
+        return debugfile;
+  }
+}
+#endif
+
   /* Then try in the global debugfile directories.
 
      Keep backward compatibility so that DEBUG_FILE_DIRECTORY being "" will
@@ -1568,6 +1606,14 @@ find_separate_debug_file_by_debuglink (struct objfile *objfile)
 	}
     }
 
+#ifdef CRASH_MERGE
+  if (debugfile.empty ()) {
+       char *name_copy;
+       name_copy = check_specified_kernel_debug_file();
+       return std::string (name_copy);
+  }
+#endif
+
   return debugfile;
 }
 
@@ -2334,8 +2380,10 @@ add_symbol_file_command (const char *args, int from_tty)
   else if (section_addrs.empty ())
     printf_unfiltered ("\n");
 
+#ifndef CRASH_MERGE
   if (from_tty && (!query ("%s", "")))
     error (_("Not confirmed."));
+#endif
 
   objf = symbol_file_add (filename.get (), add_flags, &section_addrs,
 			  flags);
@@ -3622,6 +3670,15 @@ bfd_byte *
 symfile_relocate_debug_section (struct objfile *objfile,
                                 asection *sectp, bfd_byte *buf)
 {
+#ifdef CRASH_MERGE
+  /* Executable files have all the relocations already resolved.
+   * Handle files linked with --emit-relocs.
+   * http://sources.redhat.com/ml/gdb/2006-08/msg00137.html
+   */
+  bfd *abfd = objfile->obfd;
+  if ((abfd->flags & EXEC_P) != 0)
+    return NULL;
+#endif
   gdb_assert (objfile->sf->sym_relocate);
 
   return (*objfile->sf->sym_relocate) (objfile, sectp, buf);
--- gdb-10.2/gdb/symtab.c.orig
+++ gdb-10.2/gdb/symtab.c
@@ -1870,27 +1870,46 @@ search_name_hash (enum language language, const char *search_name)
    variable and thus can probably assume it will never hit the C++
    code).  */
 
+#ifdef CRASH_MERGE
+static void gdb_bait_and_switch(char *, struct symbol *);
+#endif
+
 struct block_symbol
 lookup_symbol_in_language (const char *name, const struct block *block,
 			   const domain_enum domain, enum language lang,
 			   struct field_of_this_result *is_a_field_of_this)
 {
+  struct block_symbol result;
   demangle_result_storage storage;
   const char *modified_name = demangle_for_lookup (name, lang, storage);
 
-  return lookup_symbol_aux (modified_name,
+  result = lookup_symbol_aux (modified_name,
 			    symbol_name_match_type::FULL,
 			    block, domain, lang,
 			    is_a_field_of_this);
+#ifdef CRASH_MERGE
+  if (result.symbol && (domain == VAR_DOMAIN))
+        gdb_bait_and_switch((char *)modified_name, result.symbol);
+#endif
+  return result;
 }
 
 /* See symtab.h.  */
 
+#ifdef CRASH_MERGE
+static const struct block *gdb_get_crash_block(void);
+#endif
+
 struct block_symbol
 lookup_symbol (const char *name, const struct block *block,
 	       domain_enum domain,
 	       struct field_of_this_result *is_a_field_of_this)
 {
+#ifdef CRASH_MERGE
+  if (!block)
+    block = gdb_get_crash_block();
+#endif
+
   return lookup_symbol_in_language (name, block, domain,
 				    current_language->la_language,
 				    is_a_field_of_this);
@@ -6886,3 +6905,806 @@ If zero then the symbol cache is disabled."),
   gdb::observers::new_objfile.attach (symtab_new_objfile_observer);
   gdb::observers::free_objfile.attach (symtab_free_objfile_observer);
 }
+
+#ifdef CRASH_MERGE
+#include "gdb-stabs.h"
+#include "gdbsupport/version.h"
+#define GDB_COMMON
+#include "../../defs.h"
+
+static void get_member_data(struct gnu_request *, struct type *, long, int);
+static void dump_enum(struct type *, struct gnu_request *);
+static void eval_enum(struct type *, struct gnu_request *);
+static void gdb_get_line_number(struct gnu_request *);
+static void gdb_get_datatype(struct gnu_request *);
+static void gdb_get_symbol_type(struct gnu_request *);
+static void gdb_command_exists(struct gnu_request *);
+static void gdb_debug_command(struct gnu_request *);
+static void gdb_function_numargs(struct gnu_request *);
+static void gdb_add_symbol_file(struct gnu_request *);
+static void gdb_delete_symbol_file(struct gnu_request *);
+static void gdb_patch_symbol_values(struct gnu_request *);
+static void get_user_print_option_address(struct gnu_request *);
+extern int get_frame_offset(CORE_ADDR);
+static void gdb_set_crash_block(struct gnu_request *);
+extern "C" void gdb_command_funnel(struct gnu_request *);
+void gdb_command_funnel_1(struct gnu_request *);
+static long lookup_struct_contents(struct gnu_request *);
+static void iterate_datatypes(struct gnu_request *);
+
+struct objfile *gdb_kernel_objfile = { 0 };
+
+static ulong gdb_merge_flags = 0;
+#define KERNEL_SYMBOLS_PATCHED (0x1)
+
+#undef STREQ
+#define STREQ(A, B)      (A && B && (strcmp(A, B) == 0))
+#define TYPE_CODE(t)        (t->code ())
+#define TYPE_TAG_NAME(t) (TYPE_MAIN_TYPE(t)->name)
+#define TYPE_NFIELDS(t) (t->num_fields ())
+#define TYPE_NAME(t) (t->name ())
+
+/*
+ *  All commands from above come through here.
+ */
+void
+gdb_command_funnel(struct gnu_request *req)
+{
+        try {
+                gdb_command_funnel_1(req);
+        } catch (const gdb_exception &ex) {
+                if (req->flags & GNU_RETURN_ON_ERROR)
+                        req->flags |= GNU_COMMAND_FAILED;
+                else
+                        throw ex;
+        }
+}
+
+void
+gdb_command_funnel_1(struct gnu_request *req)
+{
+        struct symbol *sym;
+
+        if (req->command != GNU_VERSION && req->command != GNU_USER_PRINT_OPTION) {
+                (dynamic_cast<stdio_file *>gdb_stdout)->set_stream(req->fp);
+                (dynamic_cast<stdio_file *>gdb_stderr)->set_stream(req->fp);
+        }
+
+        switch (req->command)
+        {
+        case GNU_VERSION:
+                req->buf = (char *)version;
+                break;
+
+        case GNU_PASS_THROUGH:
+                execute_command(req->buf,
+                        req->flags & GNU_FROM_TTY_OFF ? FALSE : TRUE);
+                break;
+
+        case GNU_USER_PRINT_OPTION:
+                get_user_print_option_address(req);
+                break;
+
+        case GNU_RESOLVE_TEXT_ADDR:
+                sym = find_pc_function(req->addr);
+                if (!sym || TYPE_CODE(sym->type) != TYPE_CODE_FUNC)
+                        req->flags |= GNU_COMMAND_FAILED;
+                break;
+
+        case GNU_DISASSEMBLE:
+                if (req->addr2)
+                        sprintf(req->buf, "disassemble 0x%lx 0x%lx",
+                                req->addr, req->addr2);
+                else
+                        sprintf(req->buf, "disassemble 0x%lx", req->addr);
+                execute_command(req->buf, TRUE);
+                break;
+
+        case GNU_ADD_SYMBOL_FILE:
+                gdb_add_symbol_file(req);
+                break;
+
+        case GNU_DELETE_SYMBOL_FILE:
+                gdb_delete_symbol_file(req);
+                break;
+
+        case GNU_GET_LINE_NUMBER:
+                gdb_get_line_number(req);
+                break;
+
+        case GNU_GET_DATATYPE:
+                gdb_get_datatype(req);
+                break;
+
+        case GNU_GET_SYMBOL_TYPE:
+                gdb_get_symbol_type(req);
+                break;
+
+        case GNU_COMMAND_EXISTS:
+                gdb_command_exists(req);
+                break;
+
+        case GNU_ALPHA_FRAME_OFFSET:
+                req->value = 0;
+                break;
+
+        case GNU_FUNCTION_NUMARGS:
+                gdb_function_numargs(req);
+                break;
+
+        case GNU_DEBUG_COMMAND:
+                gdb_debug_command(req);
+                break;
+
+        case GNU_PATCH_SYMBOL_VALUES:
+                gdb_patch_symbol_values(req);
+                break;
+
+        case GNU_SET_CRASH_BLOCK:
+                gdb_set_crash_block(req);
+                break;
+
+        case GNU_GET_FUNCTION_RANGE:
+                {
+                        CORE_ADDR start, end;
+                        if (!find_pc_partial_function(req->pc, NULL, &start, &end))
+                                req->flags |= GNU_COMMAND_FAILED;
+                        else {
+                                req->addr = (ulong)start;
+                                req->addr2 = (ulong)end;
+                        }
+                }
+                break;
+
+        case GNU_LOOKUP_STRUCT_CONTENTS:
+                req->value = lookup_struct_contents(req);
+                break;
+
+        case GNU_ITERATE_DATATYPES:
+                iterate_datatypes(req);
+                break;
+
+        default:
+                req->flags |= GNU_COMMAND_FAILED;
+                break;
+        }
+}
+
+/*
+ *  Given a PC value, return the file and line number.
+ */
+static void
+gdb_get_line_number(struct gnu_request *req)
+{
+        struct symtab_and_line sal;
+        struct objfile *objfile;
+        CORE_ADDR pc;
+
+#define LASTCHAR(s)      (s[strlen(s)-1])
+
+        /*
+         * Prime the addrmap pump.
+         */
+        pc = req->addr;
+
+        sal = find_pc_line(pc, 0);
+
+        if (!sal.symtab) {
+                /*
+                 *  If a module address line number can't be found, it's typically
+                 *  due to its addrmap still containing offset values because its
+                 *  objfile doesn't have full symbols loaded.
+                 */
+                if (req->lm) {
+                        objfile = req->lm->loaded_objfile;
+                        if (!objfile_has_full_symbols(objfile) && objfile->sf) {
+                                objfile->sf->qf->expand_all_symtabs(objfile);
+                                sal = find_pc_line(pc, 0);
+                        }
+                }
+                if (!sal.symtab) {
+                        req->buf[0] = '\0';
+                        return;
+                }
+        }
+
+        if (sal.symtab->filename && SYMTAB_DIRNAME(sal.symtab)) {
+                if (sal.symtab->filename[0] == '/')
+                        sprintf(req->buf, "%s: %d",
+                                sal.symtab->filename, sal.line);
+                else
+                        sprintf(req->buf, "%s%s%s: %d",
+                                SYMTAB_DIRNAME(sal.symtab),
+                                LASTCHAR(SYMTAB_DIRNAME(sal.symtab)) == '/' ? "" : "/",
+                                sal.symtab->filename, sal.line);
+        }
+}
+
+
+/*
+ *  General purpose routine for determining datatypes.
+ */
+
+static void
+gdb_get_datatype(struct gnu_request *req)
+{
+        register struct type *type;
+        register struct type *typedef_type;
+        expression_up expr;
+        struct symbol *sym;
+        struct value *val;
+
+        if (gdb_CRASHDEBUG(2))
+                console("gdb_get_datatype [%s] (a)\n", req->name);
+
+        req->typecode = TYPE_CODE_UNDEF;
+
+        /*
+         *  lookup_symbol() will pick up struct and union names.
+         */
+        sym = lookup_symbol(req->name, 0, STRUCT_DOMAIN, 0).symbol;
+        if (sym) {
+                req->typecode = TYPE_CODE(sym->type);
+                req->length = TYPE_LENGTH(sym->type);
+                if (req->member)
+                        get_member_data(req, sym->type, 0, 1);
+
+                if (TYPE_CODE(sym->type) == TYPE_CODE_ENUM) {
+                        if (req->flags & GNU_PRINT_ENUMERATORS)
+                                dump_enum(sym->type, req);
+                }
+
+                return;
+        }
+
+        /*
+         *  Otherwise parse the expression.
+         */
+        if (gdb_CRASHDEBUG(2))
+                console("gdb_get_datatype [%s] (b)\n", req->name);
+
+        expr = parse_expression(req->name);
+
+
+        switch (expr.get()->elts[0].opcode)
+        {
+        case OP_VAR_VALUE:
+                if (gdb_CRASHDEBUG(2))
+                        console("expr->elts[0].opcode: OP_VAR_VALUE\n");
+                type = expr.get()->elts[2].symbol->type;
+                if (req->flags & GNU_VAR_LENGTH_TYPECODE) {
+                        req->typecode = TYPE_CODE(type);
+                        req->length = TYPE_LENGTH(type);
+                }
+                if (TYPE_CODE(type) == TYPE_CODE_ENUM) {
+                        req->typecode = TYPE_CODE(type);
+                        req->value = SYMBOL_VALUE(expr.get()->elts[2].symbol);
+                        req->tagname = (char *)TYPE_TAG_NAME(type);
+                        if (!req->tagname) {
+                                val = evaluate_type(expr.get());
+                                eval_enum(value_type(val), req);
+                        }
+                }
+                break;
+
+          case OP_TYPE:
+                if (gdb_CRASHDEBUG(2))
+                        console("expr->elts[0].opcode: OP_TYPE\n");
+                    type = expr.get()->elts[1].type;
+
+                req->typecode = TYPE_CODE(type);
+                req->length = TYPE_LENGTH(type);
+
+                if (TYPE_CODE(type) == TYPE_CODE_TYPEDEF) {
+                        req->is_typedef = TYPE_CODE_TYPEDEF;
+                        if ((typedef_type = check_typedef(type))) {
+                                req->typecode = TYPE_CODE(typedef_type);
+                                req->length = TYPE_LENGTH(typedef_type);
+                                type = typedef_type;
+                        }
+                }
+
+                if (TYPE_CODE(type) == TYPE_CODE_ENUM) {
+                        if (req->is_typedef)
+                        if (req->flags & GNU_PRINT_ENUMERATORS) {
+                                if (req->is_typedef)
+                                        fprintf_filtered(gdb_stdout,
+                                                "typedef ");
+                                dump_enum(type, req);
+                        }
+                }
+
+                if (req->member)
+                        get_member_data(req, type, 0, 1);
+
+                break;
+
+        default:
+                if (gdb_CRASHDEBUG(2))
+                        console("expr.get()->elts[0].opcode: %d (?)\n",
+                                expr.get()->elts[0].opcode);
+                break;
+
+        }
+}
+
+/*
+ *  More robust enum list dump that gdb's, showing the value of each
+ *  identifier, each on its own line.
+ */
+static void
+dump_enum(struct type *type, struct gnu_request *req)
+{
+        register int i;
+        int len;
+        long long lastval;
+
+        len = TYPE_NFIELDS (type);
+        lastval = 0;
+        if (TYPE_TAG_NAME(type))
+                fprintf_filtered(gdb_stdout,
+                        "enum %s {\n", TYPE_TAG_NAME (type));
+        else
+                fprintf_filtered(gdb_stdout, "enum {\n");
+
+        for (i = 0; i < len; i++) {
+                fprintf_filtered(gdb_stdout, "  %s",
+                        TYPE_FIELD_NAME (type, i));
+                if (lastval != TYPE_FIELD_ENUMVAL (type, i)) {
+                        fprintf_filtered (gdb_stdout, " = %s",
+                                plongest(TYPE_FIELD_ENUMVAL (type, i)));
+                        lastval = TYPE_FIELD_ENUMVAL (type, i);
+                } else
+                        fprintf_filtered(gdb_stdout, " = %s", plongest(lastval));
+                fprintf_filtered(gdb_stdout, "\n");
+                lastval++;
+        }
+        if (TYPE_TAG_NAME(type))
+                fprintf_filtered(gdb_stdout, "};\n");
+        else
+                fprintf_filtered(gdb_stdout, "} %s;\n", req->name);
+}
+
+/*
+ *  Given an enum type with no tagname, determine its value.
+ */
+static void
+eval_enum(struct type *type, struct gnu_request *req)
+{
+        register int i;
+        int len;
+        long long lastval;
+
+        len = TYPE_NFIELDS (type);
+        lastval = 0;
+
+        for (i = 0; i < len; i++) {
+                if (lastval != TYPE_FIELD_ENUMVAL (type, i))
+                        lastval = TYPE_FIELD_ENUMVAL (type, i);
+
+                if (STREQ(TYPE_FIELD_NAME(type, i), req->name)) {
+                        req->tagname = "(unknown)";
+                        req->value = lastval;
+                        return;
+                }
+                lastval++;
+        }
+}
+
+/*
+ *  Walk through a struct type's list of fields looking for the desired
+ *  member field, and when found, return its relevant data.
+ */
+static void
+get_member_data(struct gnu_request *req, struct type *type, long offset, int is_first)
+{
+        register short i;
+        struct field *nextfield;
+        short nfields;
+        struct type *typedef_type, *target_type;
+
+        req->member_offset = -1;
+
+        nfields = TYPE_MAIN_TYPE(type)->nfields;
+        nextfield = TYPE_MAIN_TYPE(type)->flds_bnds.fields;
+
+        if (nfields == 0 && is_first /* The first call */) {
+                struct type *newtype;
+                newtype = lookup_transparent_type(req->name);
+                if (newtype) {
+                        console("get_member_data(%s.%s): switching type from %lx to %lx\n",
+                                req->name, req->member, type, newtype);
+                        nfields = TYPE_MAIN_TYPE(newtype)->nfields;
+                        nextfield = TYPE_MAIN_TYPE(newtype)->flds_bnds.fields;
+                }
+        }
+
+        for (i = 0; i < nfields; i++) {
+                if (STREQ(req->member, nextfield->name)) {
+                        req->member_offset = offset + nextfield->loc.bitpos;
+                        req->member_length = TYPE_LENGTH(nextfield->type());
+                        req->member_typecode = TYPE_CODE(nextfield->type());
+                        req->member_main_type_name = (char *)TYPE_NAME(nextfield->type());
+                        req->member_main_type_tag_name = (char *)TYPE_TAG_NAME(nextfield->type());
+                        target_type = TYPE_TARGET_TYPE(nextfield->type());
+                        if (target_type) {
+                                req->member_target_type_name = (char *)TYPE_NAME(target_type);
+                                req->member_target_type_tag_name = (char *)TYPE_TAG_NAME(target_type);
+                        }
+                        if ((req->member_typecode == TYPE_CODE_TYPEDEF) &&
+                            (typedef_type = check_typedef(nextfield->type())))
+                                req->member_length = TYPE_LENGTH(typedef_type);
+                        return;
+                } else if (*nextfield->name == 0) { /* Anonymous struct/union */
+                        get_member_data(req, nextfield->type(),
+                            offset + nextfield->loc.bitpos, 0);
+                        if (req->member_offset != -1)
+                                return;
+                }
+                nextfield++;
+        }
+}
+
+/*
+ *  Check whether a command exists.  If it doesn't, the command will be
+ *  returned indirectly via the error_hook.
+ */
+static void
+gdb_command_exists(struct gnu_request *req)
+{
+        extern struct cmd_list_element *cmdlist;
+
+        req->value = FALSE;
+        lookup_cmd((const char **)&req->name, cmdlist, "", NULL, 0, 1);
+        req->value = TRUE;
+}
+
+static void
+gdb_function_numargs(struct gnu_request *req)
+{
+        struct symbol *sym;
+
+        sym = find_pc_function(req->pc);
+
+        if (!sym || TYPE_CODE(sym->type) != TYPE_CODE_FUNC) {
+                req->flags |= GNU_COMMAND_FAILED;
+                return;
+        }
+
+        req->value = (ulong)TYPE_NFIELDS(sym->type);
+}
+
+struct load_module *gdb_current_load_module = NULL;
+
+static void
+gdb_add_symbol_file(struct gnu_request *req)
+{
+        struct load_module *lm;
+        int i;
+        int allsect = 0;
+        char *secname;
+        char buf[80];
+
+        gdb_current_load_module = lm = (struct load_module *)req->addr;
+
+        req->name = lm->mod_namelist;
+        gdb_delete_symbol_file(req);
+        lm->loaded_objfile = NULL;
+
+        if ((lm->mod_flags & MOD_NOPATCH) == 0) {
+                for (i = 0 ; i < lm->mod_sections; i++) {
+                    if (STREQ(lm->mod_section_data[i].name, ".text") &&
+                        (lm->mod_section_data[i].flags & SEC_FOUND))
+                            allsect = 1;
+                }
+
+                if (!allsect) {
+                    sprintf(req->buf, "add-symbol-file %s 0x%lx %s", lm->mod_namelist,
+                            lm->mod_text_start ? lm->mod_text_start : lm->mod_base,
+                            lm->mod_flags & MOD_DO_READNOW ? "-readnow" : "");
+                    if (lm->mod_data_start) {
+                            sprintf(buf, " -s .data 0x%lx", lm->mod_data_start);
+                            strcat(req->buf, buf);
+                    }
+                    if (lm->mod_bss_start) {
+                            sprintf(buf, " -s .bss 0x%lx", lm->mod_bss_start);
+                            strcat(req->buf, buf);
+                    }
+                    if (lm->mod_rodata_start) {
+                            sprintf(buf, " -s .rodata 0x%lx", lm->mod_rodata_start);
+                            strcat(req->buf, buf);
+                    }
+                } else {
+                    sprintf(req->buf, "add-symbol-file %s 0x%lx %s", lm->mod_namelist,
+                            lm->mod_text_start, lm->mod_flags & MOD_DO_READNOW ?
+                            "-readnow" : "");
+                    for (i = 0; i < lm->mod_sections; i++) {
+                            secname = lm->mod_section_data[i].name;
+                            if ((lm->mod_section_data[i].flags & SEC_FOUND) &&
+                                !STREQ(secname, ".text")) {
+                                    sprintf(buf, " -s %s 0x%lx", secname,
+                                        lm->mod_section_data[i].offset + lm->mod_base);
+                                    strcat(req->buf, buf);
+                            }
+                    }
+                }
+        }
+
+        if (gdb_CRASHDEBUG(1))
+            fprintf_filtered(gdb_stdout, "%s\n", req->buf);
+
+               execute_command(req->buf, FALSE);
+
+        for (objfile *objfile : current_program_space->objfiles ()) {
+                if (same_file((char *)objfile_name(objfile), lm->mod_namelist)) {
+                        if (objfile->separate_debug_objfile)
+                                lm->loaded_objfile = objfile->separate_debug_objfile;
+                        else
+                                lm->loaded_objfile = objfile;
+                        break;
+                }
+        }
+
+        if (!lm->loaded_objfile)
+                req->flags |= GNU_COMMAND_FAILED;
+}
+
+static void
+gdb_delete_symbol_file(struct gnu_request *req)
+{
+        for (objfile *objfile : current_program_space->objfiles ()) {
+                if (STREQ(objfile_name(objfile), req->name) ||
+                    same_file((char *)objfile_name(objfile), req->name)) {
+                        objfile->unlink ();
+                        break;
+                }
+        }
+
+        if (gdb_CRASHDEBUG(2)) {
+                fprintf_filtered(gdb_stdout, "current object files:\n");
+                for (objfile *objfile : current_program_space->objfiles ())
+                        fprintf_filtered(gdb_stdout, "  %s\n", objfile_name(objfile));
+        }
+}
+
+/*
+ *  Walk through all minimal_symbols, patching their values with the
+ *  correct addresses.
+ */
+static void
+gdb_patch_symbol_values(struct gnu_request *req)
+{
+        req->name = PATCH_KERNEL_SYMBOLS_START;
+        patch_kernel_symbol(req);
+
+       for (objfile *objfile : current_program_space->objfiles ())
+           for (minimal_symbol *msymbol : objfile->msymbols ())
+        {
+                req->name = (char *)msymbol->m_name;
+                req->addr = (ulong)(&MSYMBOL_VALUE(msymbol));
+                if (!patch_kernel_symbol(req)) {
+                        req->flags |= GNU_COMMAND_FAILED;
+                        break;
+                }
+        }
+
+        req->name = PATCH_KERNEL_SYMBOLS_STOP;
+        patch_kernel_symbol(req);
+
+        clear_symtab_users(0);
+        gdb_merge_flags |= KERNEL_SYMBOLS_PATCHED;
+}
+
+static void
+gdb_get_symbol_type(struct gnu_request *req)
+{
+        expression_up expr;
+        struct value *val;
+        struct type *type;
+        struct type *target_type;
+
+        req->typecode = TYPE_CODE_UNDEF;
+
+        expr = parse_expression (req->name);
+        val = evaluate_type (expr.get());
+
+        type = value_type(val);
+
+        req->type_name = (char *)TYPE_MAIN_TYPE(type)->name;
+        req->typecode = TYPE_MAIN_TYPE(type)->code;
+        req->length = type->length;
+        req->type_tag_name = (char *)TYPE_TAG_NAME(type);
+        target_type = TYPE_MAIN_TYPE(type)->target_type;
+
+        if (target_type) {
+                req->target_typename = (char *)TYPE_MAIN_TYPE(target_type)->name;
+                req->target_typecode = TYPE_MAIN_TYPE(target_type)->code;
+                req->target_length = target_type->length;
+        }
+
+        if (req->member)
+                get_member_data(req, type, 0, 1);
+}
+
+static void
+gdb_debug_command(struct gnu_request *req)
+{
+
+}
+
+/*
+ *  Only necessary on "patched" kernel symbol sessions, and called only by
+ *  lookup_symbol(), pull a symbol value bait-and-switch operation by altering
+ *  either a data symbol's address value or a text symbol's block start address.
+ */
+static void
+gdb_bait_and_switch(char *name, struct symbol *sym)
+{
+        struct bound_minimal_symbol msym;
+        struct block *block;
+
+        if ((gdb_merge_flags & KERNEL_SYMBOLS_PATCHED) &&
+            (msym = lookup_minimal_symbol(name, NULL, gdb_kernel_objfile)).minsym) {
+                if (SYMBOL_CLASS(sym) == LOC_BLOCK) {
+                        block = (struct block *)SYMBOL_BLOCK_VALUE(sym);
+                        BLOCK_START(block) = BMSYMBOL_VALUE_ADDRESS(msym);
+                } else
+                        SET_SYMBOL_VALUE_ADDRESS(sym, BMSYMBOL_VALUE_ADDRESS(msym));
+        }
+}
+
+#include "valprint.h"
+
+void
+get_user_print_option_address(struct gnu_request *req)
+{
+        extern struct value_print_options user_print_options;
+
+        req->addr = 0;
+
+        if (strcmp(req->name, "output_format") == 0)
+                req->addr = (ulong)&user_print_options.output_format;
+        if (strcmp(req->name, "print_max") == 0)
+                req->addr = (ulong)&user_print_options.print_max;
+        if (strcmp(req->name, "prettyprint_structs") == 0)
+                req->addr = (ulong)&user_print_options.prettyformat_structs;
+        if (strcmp(req->name, "prettyprint_arrays") == 0)
+                req->addr = (ulong)&user_print_options.prettyformat_arrays;
+        if (strcmp(req->name, "repeat_count_threshold") == 0)
+                req->addr = (ulong)&user_print_options.repeat_count_threshold;
+        if (strcmp(req->name, "stop_print_at_null") == 0)
+                req->addr = (ulong)&user_print_options.stop_print_at_null;
+        if (strcmp(req->name, "output_radix") == 0)
+                req->addr = (ulong)&output_radix;
+}
+
+CORE_ADDR crash_text_scope;
+
+static void
+gdb_set_crash_block(struct gnu_request *req)
+{
+        if (!req->addr) {  /* debug */
+                crash_text_scope = 0;
+                return;
+        }
+
+        if ((req->addr2 = (ulong)block_for_pc(req->addr)))
+                crash_text_scope = req->addr;
+        else {
+                crash_text_scope = 0;
+                req->flags |= GNU_COMMAND_FAILED;
+        }
+}
+
+static const struct block *
+gdb_get_crash_block(void)
+{
+        if (crash_text_scope)
+                return block_for_pc(crash_text_scope);
+        else
+                return NULL;
+}
+
+static long
+lookup_struct_contents(struct gnu_request *req)
+{
+  int i;
+  long r;
+  struct field *f;
+  struct main_type *m;
+  const char *n;
+  struct main_type *top_m = (struct main_type *)req->addr;
+  char *type_name = req->type_name;
+
+  if (!top_m || !type_name)
+    return 0;
+
+  for (i = 0; i < top_m->nfields; i++)
+    {
+      f = top_m->flds_bnds.fields + i;
+      if (!f->type())
+        continue;
+      m = f->type()->main_type;
+
+      // If the field is an array, check the target type -
+      // it might be structure, or might not be.
+      // - struct request_sock *syn_table[0];
+      //   here m->target_type->main_type->code is expected
+      //   to be TYPE_CODE_PTR
+      // - struct list_head vec[TVN_SIZE];
+      //   here m->target_type->main_type->code should be
+      //   TYPE_CODE_STRUCT
+      if (m->code == TYPE_CODE_ARRAY && m->target_type)
+        m = m->target_type->main_type;
+
+      /* Here is a recursion.
+       * If we have struct variable (not pointer),
+       * scan this inner structure
+       */
+      if (m->code == TYPE_CODE_STRUCT) {
+        req->addr = (ulong)m;
+        r = lookup_struct_contents(req);
+        req->addr = (ulong)top_m;
+        if (r)
+          return 1;
+      }
+
+      if (m->code == TYPE_CODE_PTR && m->target_type)
+        m = m->target_type->main_type;
+      if (m->name)
+        n = m->name;
+      else
+        continue;
+
+      if (strstr(n, type_name))
+        return 1;
+    }
+
+  return 0;
+}
+
+static void
+iterate_datatypes (struct gnu_request *req)
+{
+  for (objfile *objfile : current_program_space->objfiles ())
+    {
+      if (objfile->sf)
+        objfile->sf->qf->expand_all_symtabs(objfile);
+
+      for (compunit_symtab *cust : objfile->compunits ())
+        {
+          const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (cust);
+
+          for (int i = GLOBAL_BLOCK; i <= STATIC_BLOCK; ++i)
+            {
+              const struct block *b = BLOCKVECTOR_BLOCK (bv, i);
+              struct block_iterator iter;
+              struct symbol *sym;
+
+              ALL_BLOCK_SYMBOLS (b, iter, sym)
+                {
+                  QUIT;
+
+                  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)
+                    continue;
+
+                  if (req->highest &&
+                    !(req->lowest <= sym->type->length && sym->type->length <= req->highest))
+                        continue;
+
+                  req->addr = (ulong)(sym->type->main_type);
+                  req->name = (char *)(sym->m_name);
+                  req->length = sym->type->length;
+
+                  if (req->member) {
+                    req->value = lookup_struct_contents(req);
+                    if (!req->value)
+                      continue;
+                  }
+                  req->callback(req, req->callback_data);
+                }
+            }
+        }
+    }
+}
+#endif
--- gdb-10.2/gdb/ui-file.h.orig
+++ gdb-10.2/gdb/ui-file.h
@@ -195,10 +195,10 @@ class stdio_file : public ui_file
 
   bool can_emit_style_escape () override;
 
-private:
   /* Sets the internal stream to FILE, and saves the FILE's file
      descriptor in M_FD.  */
   void set_stream (FILE *file);
+private:
 
   /* The file.  */
   FILE *m_file;
--- gdb-10.2/gdb/xml-syscall.c.orig
+++ gdb-10.2/gdb/xml-syscall.c
@@ -37,7 +37,11 @@
 static void
 syscall_warn_user (void)
 {
+#ifdef CRASH_MERGE
+  static int have_warned = 1;
+#else
   static int have_warned = 0;
+#endif
   if (!have_warned)
     {
       have_warned = 1;
--- gdb-10.2/libiberty/Makefile.in.orig
+++ gdb-10.2/libiberty/Makefile.in
@@ -180,6 +180,7 @@ REQUIRED_OFILES =							\
 	./getruntime.$(objext) ./hashtab.$(objext) ./hex.$(objext)	\
 	./lbasename.$(objext) ./lrealpath.$(objext)			\
 	./make-relative-prefix.$(objext) ./make-temp-file.$(objext)	\
+	./mkstemps.$(objext)                                            \
 	./objalloc.$(objext)						\
 	./obstack.$(objext)						\
 	./partition.$(objext) ./pexecute.$(objext) ./physmem.$(objext)	\
@@ -213,7 +214,7 @@ CONFIGURED_OFILES = ./asprintf.$(objext) ./atexit.$(objext)		\
 	./index.$(objext) ./insque.$(objext)				\
 	./memchr.$(objext) ./memcmp.$(objext) ./memcpy.$(objext) 	\
 	./memmem.$(objext) ./memmove.$(objext)				\
-	 ./mempcpy.$(objext) ./memset.$(objext) ./mkstemps.$(objext)	\
+	 ./mempcpy.$(objext) ./memset.$(objext) 			\
 	./pex-djgpp.$(objext) ./pex-msdos.$(objext)			\
 	 ./pex-unix.$(objext) ./pex-win32.$(objext)			\
 	 ./putenv.$(objext)						\
--- gdb-10.2/opcodes/i386-dis.c.orig
+++ gdb-10.2/opcodes/i386-dis.c
@@ -9778,6 +9778,10 @@ print_insn (bfd_vma pc, disassemble_info *info)
       threebyte = *codep;
       dp = &dis386_twobyte[threebyte];
       need_modrm = twobyte_has_modrm[*codep];
+      if (dp->name && ((strcmp(dp->name, "ud2a") == 0) || (strcmp(dp->name, "ud2") == 0))) {
+        extern int kernel_BUG_encoding_bytes(void);
+        codep += kernel_BUG_encoding_bytes();
+      }
       codep++;
     }
   else
--- gdb-10.2/readline/readline/misc.c.orig
+++ gdb-10.2/readline/readline/misc.c
@@ -403,7 +403,7 @@ _rl_history_set_point (void)
 
 #if defined (VI_MODE)
   if (rl_editing_mode == vi_mode && _rl_keymap != vi_insertion_keymap)
-    rl_point = 0;
+    rl_point = rl_end;
 #endif /* VI_MODE */
 
   if (rl_editing_mode == emacs_mode)
--- gdb-10.2/readline/readline/readline.h.orig
+++ gdb-10.2/readline/readline/readline.h
@@ -395,7 +395,7 @@ extern int rl_crlf PARAMS((void));
 #if defined (USE_VARARGS) && defined (PREFER_STDARG)
 extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
 #else
-extern int rl_message ();
+extern int rl_message (void);
 #endif
 
 extern int rl_show_char PARAMS((int));
--- gdb-10.2/readline/readline/rltypedefs.h.orig
+++ gdb-10.2/readline/readline/rltypedefs.h
@@ -32,10 +32,10 @@ extern "C" {
 #  define _FUNCTION_DEF
 
 #if defined(__GNUC__) || defined(__clang__)
-typedef int Function () __attribute__ ((deprecated));
-typedef void VFunction () __attribute__ ((deprecated));
-typedef char *CPFunction () __attribute__ ((deprecated));
-typedef char **CPPFunction () __attribute__ ((deprecated));
+typedef int Function (void) __attribute__ ((deprecated));
+typedef void VFunction (void) __attribute__ ((deprecated));
+typedef char *CPFunction (void) __attribute__ ((deprecated));
+typedef char **CPPFunction (void) __attribute__ ((deprecated));
 #else
 typedef int Function ();
 typedef void VFunction ();
--- gdb-10.2/readline/readline/util.c.orig
+++ gdb-10.2/readline/readline/util.c
@@ -487,10 +487,13 @@ _rl_trace (va_alist)
 
   if (_rl_tracefp == 0)
     _rl_tropen ();
+  if (!_rl_tracefp)
+    goto out;
   vfprintf (_rl_tracefp, format, args);
   fprintf (_rl_tracefp, "\n");
   fflush (_rl_tracefp);
 
+out:
   va_end (args);
 }
 
@@ -513,16 +516,17 @@ _rl_tropen (void)
   sprintf (fnbuf, "/var/tmp/rltrace.%ld", (long) getpid ());
 #endif
   unlink (fnbuf);
-  _rl_tracefp = fopen (fnbuf, "w+");
+  _rl_tracefp = fopen (fnbuf, "w+xe");
   return _rl_tracefp != 0;
 }
 
 int
 _rl_trclose (void)
 {
-  int r;
+  int r = 0;
 
-  r = fclose (_rl_tracefp);
+  if (_rl_tracefp)
+    r = fclose (_rl_tracefp);
   _rl_tracefp = 0;
   return r;
 }
--- gdb-10.2/gdb/completer.c.orig
+++ gdb-10.2/gdb/completer.c
@@ -2949,6 +2949,8 @@
 
   /* How many items of MAX length can we fit in the screen window? */
   cols = gdb_complete_get_screenwidth (displayer);
+  rl_reset_screen_size();
+  rl_get_screen_size(NULL, &cols);
   max += 2;
   limit = cols / max;
   if (limit != 1 && (limit * max == cols))
--- gdb-10.2/gdb/ada-lang.c.orig
+++ gdb-10.2/gdb/ada-lang.c
@@ -997,7 +997,7 @@ ada_fold_name (gdb::string_view name)
   int len = name.size ();
   GROW_VECT (fold_buffer, fold_buffer_size, len + 1);
 
-  if (name[0] == '\'')
+  if (!name.empty () && name[0] == '\'')
     {
       strncpy (fold_buffer, name.data () + 1, len - 2);
       fold_buffer[len - 2] = '\000';
@@ -1006,8 +1006,9 @@ ada_fold_name (gdb::string_view name)
     {
       int i;
 
-      for (i = 0; i <= len; i += 1)
+      for (i = 0; i < len; i += 1)
         fold_buffer[i] = tolower (name[i]);
+      fold_buffer[i] = '\0';
     }
 
   return fold_buffer;
@@ -13596,7 +13597,7 @@ ada_lookup_name_info::ada_lookup_name_info (const lookup_name_info &lookup_name)
 {
   gdb::string_view user_name = lookup_name.name ();
 
-  if (user_name[0] == '<')
+  if (!user_name.empty () && user_name[0] == '<')
     {
       if (user_name.back () == '>')
 	m_encoded_name
--- gdb-10.2/gdb/Makefile.in.orig
+++ gdb-10.2/gdb/Makefile.in
@@ -1865,7 +1865,7 @@ libgdb.a: $(LIBGDB_OBS)
 # Removing the old gdb first works better if it is running, at least on SunOS.
 gdb$(EXEEXT): gdb.o $(LIBGDB_OBS) $(CDEPS) $(TDEPLIBS)
 	$(SILENCE) rm -f gdb$(EXEEXT)
-	@(cd ../..; make --no-print-directory GDB_FLAGS=-DGDB_10_2 library)
+	@$(MAKE) -C ../.. GDB_FLAGS=-DGDB_10_2 library
 	$(ECHO_CXXLD) $(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
                 -o $(shell /bin/cat mergeobj) $(LIBGDB_OBS) \
                 $(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES) $(shell /bin/cat mergelibs)
--- gdb-10.2/gdb/c-typeprint.c.orig
+++ gdb-10.2/gdb/c-typeprint.c
@@ -1202,6 +1202,9 @@ c_type_print_base_struct_union (struct t
 		= podata->end_bitpos
 		  - TYPE_LENGTH (type->field (i).type ()) * TARGET_CHAR_BIT;
 	    }
+	  else if (strlen(TYPE_FIELD_NAME (type, i)) == 0)
+	    /* crash: Print details for unnamed struct and union. */
+	    newshow = show;

 	  c_print_type_1 (type->field (i).type (),
 			  TYPE_FIELD_NAME (type, i),
--- gdb-10.2/gdb/symfile.c.orig
+++ gdb-10.2/gdb/symfile.c
@@ -1610,7 +1610,7 @@ find_separate_debug_file_by_debuglink (struct objfile *objfile)
   if (debugfile.empty ()) {
        char *name_copy;
        name_copy = check_specified_kernel_debug_file();
-       return std::string (name_copy);
+       return name_copy ? std::string (name_copy) : std::string ();
   }
 #endif
 
--- gdb-10.2/gdb/printcmd.c.orig
+++ gdb-10.2/gdb/printcmd.c
@@ -576,6 +576,10 @@ print_address_symbolic (struct gdbarch *gdbarch, CORE_ADDR addr,
 
 /* See valprint.h.  */
 
+#ifdef CRASH_MERGE
+extern "C" char *gdb_lookup_module_symbol(unsigned long, unsigned long *);
+#endif
+
 int
 build_address_symbolic (struct gdbarch *gdbarch,
 			CORE_ADDR addr,  /* IN */
@@ -682,7 +686,19 @@ build_address_symbolic (struct gdbarch *gdbarch,
 	}
     }
   if (symbol == NULL && msymbol.minsym == NULL)
+#ifdef CRASH_MERGE
+  {
+    char *name_ptr = gdb_lookup_module_symbol(addr, (unsigned long *)offset);
+    if (name_ptr) {
+      *name = name_ptr;
+      return 0;
+    } else {
+      return 1;
+    }
+  }
+#else
     return 1;
+#endif
 
   /* If the nearest symbol is too far away, don't print anything symbolic.  */
 
--- gdb-10.2/gdb/symtab.c.orig
+++ gdb-10.2/gdb/symtab.c
@@ -7128,8 +7128,8 @@ gdb_get_line_number(struct gnu_request *
 static void
 gdb_get_datatype(struct gnu_request *req)
 {
-        register struct type *type;
-        register struct type *typedef_type;
+        struct type *type;
+        struct type *typedef_type;
         expression_up expr;
         struct symbol *sym;
         struct value *val;
@@ -7235,7 +7235,7 @@ gdb_get_datatype(struct gnu_request *req
 static void
 dump_enum(struct type *type, struct gnu_request *req)
 {
-        register int i;
+        int i;
         int len;
         long long lastval;
 
@@ -7271,7 +7271,7 @@ dump_enum(struct type *type, struct gnu_
 static void
 eval_enum(struct type *type, struct gnu_request *req)
 {
-        register int i;
+        int i;
         int len;
         long long lastval;
 
@@ -7298,7 +7298,7 @@ eval_enum(struct type *type, struct gnu_
 static void
 get_member_data(struct gnu_request *req, struct type *type, long offset, int is_first)
 {
-        register short i;
+        short i;
         struct field *nextfield;
         short nfields;
         struct type *typedef_type, *target_type;
--- gdb-10.2/gdb/symtab.c.orig
+++ gdb-10.2/gdb/symtab.c
@@ -6913,7 +6913,7 @@
 #include "../../defs.h"
 
 static void get_member_data(struct gnu_request *, struct type *, long, int);
-static void dump_enum(struct type *, struct gnu_request *);
+static void walk_enum(struct type *, struct gnu_request *);
 static void eval_enum(struct type *, struct gnu_request *);
 static void gdb_get_line_number(struct gnu_request *);
 static void gdb_get_datatype(struct gnu_request *);
@@ -7122,6 +7122,79 @@
 
 
 /*
+ * Follow the type linkage for full member and value type resolution, with callback
+ */
+static void drillDownType(struct gnu_request *req, struct type *type)
+{
+        while (type)
+        {
+                /* check out for stub types and pull in the definition instead */
+                if (TYPE_STUB(type) && TYPE_TAG_NAME(type)) {
+                        struct symbol *sym;
+                        sym = lookup_symbol(TYPE_TAG_NAME(type), 0, STRUCT_DOMAIN, 0).symbol;
+                        if (sym)
+                                type = sym->type;
+                }
+                switch (TYPE_CODE(type)) {
+                        drill_ops_t op;
+                        long l1, l2;
+                        int typecode;
+
+                case TYPE_CODE_PTR:
+                        req->tcb(EOP_POINTER, req, 0, 0, 0, 0);
+                        break;
+
+                case TYPE_CODE_TYPEDEF:
+                        req->is_typedef = 1;
+                        req->typecode = TYPE_CODE(type);
+                        if (!req->tcb(EOP_TYPEDEF, req, TYPE_NAME(type), 0, 0, 0))
+                                return;
+                        break;
+
+                case TYPE_CODE_FUNC:
+                        req->tcb(EOP_FUNCTION, req, 0, 0, 0, 0);
+                        break;
+
+                case TYPE_CODE_ARRAY:
+                        l1 = TYPE_LENGTH (type);
+                        l2 = TYPE_LENGTH (check_typedef(TYPE_TARGET_TYPE (type)));
+                        req->tcb(EOP_ARRAY, req, &l1, &l2, 0, 0);
+                        break;
+
+                case TYPE_CODE_VOID:
+                case TYPE_CODE_INT:
+                case TYPE_CODE_BOOL:
+                        l1 = TYPE_LENGTH(type);
+                        req->tcb(EOP_INT, req, &l1, 0, 0, 0);
+                        break;
+
+                case TYPE_CODE_UNION:
+                        op = EOP_UNION;
+                        goto label;
+
+                case TYPE_CODE_ENUM:
+                        op = EOP_ENUM;
+                        goto label;
+
+                case TYPE_CODE_STRUCT:
+                        op = EOP_STRUCT;
+                        goto label;
+
+                default:
+                        typecode = TYPE_CODE(type);
+                        req->tcb(EOP_OOPS, req, &typecode, "Unknown typecode", 0, 0);
+                        return; /* not reached */
+
+                label:
+                        l1 = TYPE_LENGTH(type);
+                        req->tcb(op, req, &l1, type, TYPE_TAG_NAME(type), 0);
+                }
+                type = TYPE_TARGET_TYPE(type);
+        }
+        req->tcb(EOP_DONE, req, 0, 0, 0, 0);
+}
+
+/*
  *  General purpose routine for determining datatypes.
  */
 
@@ -7149,10 +7222,8 @@
                 if (req->member)
                         get_member_data(req, sym->type, 0, 1);
 
-                if (TYPE_CODE(sym->type) == TYPE_CODE_ENUM) {
-                        if (req->flags & GNU_PRINT_ENUMERATORS)
-                                dump_enum(sym->type, req);
-                }
+                if (TYPE_CODE(sym->type) == TYPE_CODE_ENUM)
+                        walk_enum(sym->type, req);
 
                 return;
         }
@@ -7172,17 +7243,25 @@
                 if (gdb_CRASHDEBUG(2))
                         console("expr->elts[0].opcode: OP_VAR_VALUE\n");
                 type = expr.get()->elts[2].symbol->type;
-                if (req->flags & GNU_VAR_LENGTH_TYPECODE) {
+                if (req->tcb) {
+                        long value = SYMBOL_VALUE(expr->elts[2].symbol);
+                        /* callback with symbol value */
                         req->typecode = TYPE_CODE(type);
-                        req->length = TYPE_LENGTH(type);
-                }
-                if (TYPE_CODE(type) == TYPE_CODE_ENUM) {
-                        req->typecode = TYPE_CODE(type);
-                        req->value = SYMBOL_VALUE(expr.get()->elts[2].symbol);
-                        req->tagname = (char *)TYPE_TAG_NAME(type);
-                        if (!req->tagname) {
-                                val = evaluate_type(expr.get());
-                                eval_enum(value_type(val), req);
+                        req->tcb(EOP_VALUE, req, &value, 0, 0, 0);
+                        drillDownType(req, type);
+                } else {
+                        if (req->flags & GNU_VAR_LENGTH_TYPECODE) {
+                                req->typecode = TYPE_CODE(type);
+                                req->length = TYPE_LENGTH(type);
+                        }
+                        if (TYPE_CODE(type) == TYPE_CODE_ENUM) {
+                                req->typecode = TYPE_CODE(type);
+                                req->value = SYMBOL_VALUE(expr->elts[2].symbol);
+                                req->tagname = (char *)TYPE_TAG_NAME(type);
+                                if (!req->tagname) {
+                                        val = evaluate_type(expr.get());
+                                        eval_enum(value_type(val), req);
+                                }
                         }
                 }
                 break;
@@ -7192,26 +7271,21 @@
                         console("expr->elts[0].opcode: OP_TYPE\n");
                     type = expr.get()->elts[1].type;
 
-                req->typecode = TYPE_CODE(type);
-                req->length = TYPE_LENGTH(type);
-
-                if (TYPE_CODE(type) == TYPE_CODE_TYPEDEF) {
-                        req->is_typedef = TYPE_CODE_TYPEDEF;
-                        if ((typedef_type = check_typedef(type))) {
-                                req->typecode = TYPE_CODE(typedef_type);
-                                req->length = TYPE_LENGTH(typedef_type);
-                                type = typedef_type;
-                        }
-                }
-
-                if (TYPE_CODE(type) == TYPE_CODE_ENUM) {
-                        if (req->is_typedef)
-                        if (req->flags & GNU_PRINT_ENUMERATORS) {
-                                if (req->is_typedef)
-                                        fprintf_filtered(gdb_stdout,
-                                                "typedef ");
-                                dump_enum(type, req);
+                if (req->tcb) {
+                        drillDownType(req, type);
+                } else {
+                        req->typecode = TYPE_CODE(type);
+                        req->length = TYPE_LENGTH(type);
+                        if (TYPE_CODE(type) == TYPE_CODE_TYPEDEF) {
+                                req->is_typedef = TYPE_CODE_TYPEDEF;
+                                if ((typedef_type = check_typedef(type))) {
+                                        req->typecode = TYPE_CODE(typedef_type);
+                                        req->length = TYPE_LENGTH(typedef_type);
+                                        type = typedef_type;
+                                }
                         }
+                        if (TYPE_CODE(type) == TYPE_CODE_ENUM)
+                                walk_enum(type, req);
                 }
 
                 if (req->member)
@@ -7233,36 +7307,38 @@
  *  identifier, each on its own line.
  */
 static void
-dump_enum(struct type *type, struct gnu_request *req)
+walk_enum(struct type *type, struct gnu_request *req)
 {
         int i;
-        int len;
+        int len, print = (req->flags & GNU_PRINT_ENUMERATORS);
         long long lastval;
 
-        len = TYPE_NFIELDS (type);
-        lastval = 0;
-        if (TYPE_TAG_NAME(type))
-                fprintf_filtered(gdb_stdout,
-                        "enum %s {\n", TYPE_TAG_NAME (type));
-        else
-                fprintf_filtered(gdb_stdout, "enum {\n");
+        if (print) {
+                if (req->is_typedef)
+                        fprintf_filtered(gdb_stdout, "typedef ");
+                if (TYPE_TAG_NAME(type))
+                        fprintf_filtered(gdb_stdout, "enum %s {\n", TYPE_TAG_NAME (type));
+                else
+                        fprintf_filtered(gdb_stdout, "enum {\n");
+        }
 
+        len = TYPE_NFIELDS (type);
         for (i = 0; i < len; i++) {
-                fprintf_filtered(gdb_stdout, "  %s",
-                        TYPE_FIELD_NAME (type, i));
-                if (lastval != TYPE_FIELD_ENUMVAL (type, i)) {
-                        fprintf_filtered (gdb_stdout, " = %s",
-                                plongest(TYPE_FIELD_ENUMVAL (type, i)));
-                        lastval = TYPE_FIELD_ENUMVAL (type, i);
-                } else
+                if (print)
+                        fprintf_filtered(gdb_stdout, "  %s", TYPE_FIELD_NAME (type, i));
+                lastval = TYPE_FIELD_ENUMVAL (type, i);
+                if (print) {
                         fprintf_filtered(gdb_stdout, " = %s", plongest(lastval));
-                fprintf_filtered(gdb_stdout, "\n");
-                lastval++;
+                        fprintf_filtered(gdb_stdout, "\n");
+                } else if (req->tcb)
+                        req->tcb(EOP_ENUMVAL, req, TYPE_FIELD_NAME (type, i), &lastval, 0, 0);
+        }
+        if (print) {
+                if (TYPE_TAG_NAME(type))
+                        fprintf_filtered(gdb_stdout, "};\n");
+                else
+                        fprintf_filtered(gdb_stdout, "} %s;\n", req->name);
         }
-        if (TYPE_TAG_NAME(type))
-                fprintf_filtered(gdb_stdout, "};\n");
-        else
-                fprintf_filtered(gdb_stdout, "} %s;\n", req->name);
 }
 
 /*
@@ -7320,26 +7396,43 @@
         }
 
         for (i = 0; i < nfields; i++) {
-                if (STREQ(req->member, nextfield->name)) {
-                        req->member_offset = offset + nextfield->loc.bitpos;
-                        req->member_length = TYPE_LENGTH(nextfield->type());
-                        req->member_typecode = TYPE_CODE(nextfield->type());
-                        req->member_main_type_name = (char *)TYPE_NAME(nextfield->type());
-                        req->member_main_type_tag_name = (char *)TYPE_TAG_NAME(nextfield->type());
-                        target_type = TYPE_TARGET_TYPE(nextfield->type());
-                        if (target_type) {
-                                req->member_target_type_name = (char *)TYPE_NAME(target_type);
-                                req->member_target_type_tag_name = (char *)TYPE_TAG_NAME(target_type);
-                        }
-                        if ((req->member_typecode == TYPE_CODE_TYPEDEF) &&
-                            (typedef_type = check_typedef(nextfield->type())))
-                                req->member_length = TYPE_LENGTH(typedef_type);
-                        return;
-                } else if (*nextfield->name == 0) { /* Anonymous struct/union */
+                if (*nextfield->name == 0) { /* Anonymous struct/union */
                         get_member_data(req, nextfield->type(),
                             offset + nextfield->loc.bitpos, 0);
                         if (req->member_offset != -1)
                                 return;
+                } else {
+                        /* callback may be just looking for a specific member name */
+                        if (req->tcb) {
+                                if (req->tcb(EOP_MEMBER_NAME, req, nextfield->name, 0, 0, 0)) {
+                                        long bitpos = FIELD_BITPOS(*nextfield);
+                                        long bitsize = FIELD_BITSIZE(*nextfield);
+                                        long len = TYPE_LENGTH(nextfield->type());
+                                        long byteOffset;
+                                        offset += nextfield->loc.bitpos;
+                                        byteOffset = offset/8;
+                                        console("EOP_MEMBER_SIZES\n");
+                                        req->tcb(EOP_MEMBER_SIZES, req, &byteOffset, &len, &bitpos, &bitsize);
+                                        /* callback with full type info */
+                                        drillDownType(req, nextfield->type());
+                                }
+                        } else if (STREQ(req->member, nextfield->name)) {
+                                req->member_offset = offset + nextfield->loc.bitpos;
+                                req->member_length = TYPE_LENGTH(nextfield->type());
+                                req->member_typecode = TYPE_CODE(nextfield->type());
+                                req->member_main_type_name = (char *)TYPE_NAME(nextfield->type());
+                                req->member_main_type_tag_name = (char *)TYPE_TAG_NAME(nextfield->type());
+                                target_type = TYPE_TARGET_TYPE(nextfield->type());
+                                if (target_type) {
+                                        req->member_target_type_name = (char *)TYPE_NAME(target_type);
+                                        req->member_target_type_tag_name = (char *)TYPE_TAG_NAME(target_type);
+                                }
+                                if ((req->member_typecode == TYPE_CODE_TYPEDEF) &&
+                                    (typedef_type = check_typedef(nextfield->type()))) {
+                                        req->member_length = TYPE_LENGTH(typedef_type);
+                                }
+                                return;
+                        }
                 }
                 nextfield++;
         }
--- gdb-10.2/gdb/gdbtypes.c.orig
+++ gdb-10.2/gdb/gdbtypes.c
@@ -5492,27 +5492,25 @@ copy_type_recursive (struct objfile *objfile,
 }
 
 /* Make a copy of the given TYPE, except that the pointer & reference
-   types are not preserved.
-   
-   This function assumes that the given type has an associated objfile.
-   This objfile is used to allocate the new type.  */
+   types are not preserved. */
 
 struct type *
 copy_type (const struct type *type)
 {
-  struct type *new_type;
-
-  gdb_assert (TYPE_OBJFILE_OWNED (type));
+  struct type *new_type = alloc_type_copy (type);
 
-  new_type = alloc_type_copy (type);
   TYPE_INSTANCE_FLAGS (new_type) = TYPE_INSTANCE_FLAGS (type);
   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);
   memcpy (TYPE_MAIN_TYPE (new_type), TYPE_MAIN_TYPE (type),
 	  sizeof (struct main_type));
   if (type->main_type->dyn_prop_list != NULL)
-    new_type->main_type->dyn_prop_list
-      = copy_dynamic_prop_list (&TYPE_OBJFILE (type) -> objfile_obstack,
-				type->main_type->dyn_prop_list);
+    {
+      struct obstack *storage = (TYPE_OBJFILE_OWNED (type)
+                                ? &TYPE_OBJFILE (type)->objfile_obstack
+                                : gdbarch_obstack (TYPE_OWNER (type).gdbarch));
+      new_type->main_type->dyn_prop_list
+       = copy_dynamic_prop_list (storage, type->main_type->dyn_prop_list);
+    }
 
   return new_type;
 }
--- gdb-10.2/bfd/elf-bfd.h.orig
+++ gdb-10.2/bfd/elf-bfd.h
@@ -27,6 +27,8 @@
 #include "elf/internal.h"
 #include "bfdlink.h"
 
+#include <string.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
--- gdb-10.2/gnulib/import/cdefs.h.orig
+++ gdb-10.2/gnulib/import/cdefs.h
@@ -1,17 +1,18 @@
-/* Copyright (C) 1992-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1992-2023 Free Software Foundation, Inc.
+   Copyright The GNU Toolchain Authors.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public
+   modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
-   version 3 of the License, or (at your option) any later version.
+   version 2.1 of the License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public
+   You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
@@ -25,16 +26,38 @@
 
 /* The GNU libc does not support any K&R compilers or the traditional mode
    of ISO C compilers anymore.  Check for some of the combinations not
-   anymore supported.  */
-#if defined __GNUC__ && !defined __STDC__
-# error "You need a ISO C conforming compiler to use the glibc headers"
+   supported anymore.  */
+#if defined __GNUC__ && !defined __STDC__ && !defined __cplusplus
+# error "You need a ISO C or C++ conforming compiler to use the glibc headers"
 #endif
 
 /* Some user header file might have defined this before.  */
 #undef	__P
 #undef	__PMT
 
-#ifdef __GNUC__
+/* Compilers that lack __has_attribute may object to
+       #if defined __has_attribute && __has_attribute (...)
+   even though they do not need to evaluate the right-hand side of the &&.
+   Similarly for __has_builtin, etc.  */
+#if (defined __has_attribute \
+     && (!defined __clang_minor__ \
+         || 3 < __clang_major__ + (5 <= __clang_minor__)))
+# define __glibc_has_attribute(attr) __has_attribute (attr)
+#else
+# define __glibc_has_attribute(attr) 0
+#endif
+#ifdef __has_builtin
+# define __glibc_has_builtin(name) __has_builtin (name)
+#else
+# define __glibc_has_builtin(name) 0
+#endif
+#ifdef __has_extension
+# define __glibc_has_extension(ext) __has_extension (ext)
+#else
+# define __glibc_has_extension(ext) 0
+#endif
+
+#if defined __GNUC__ || defined __clang__
 
 /* All functions, except those with callbacks or those that
    synchronize memory, are leaf functions.  */
@@ -47,21 +70,26 @@
 # endif
 
 /* GCC can always grok prototypes.  For C++ programs we add throw()
-   to help it optimize the function calls.  But this works only with
-   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
+   to help it optimize the function calls.  But this only works with
+   gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
    as non-throwing using a function attribute since programs can use
    the -fexceptions options for C code as well.  */
-# if !defined __cplusplus && __GNUC_PREREQ (3, 3)
+# if !defined __cplusplus \
+     && (__GNUC_PREREQ (3, 4) || __glibc_has_attribute (__nothrow__))
 #  define __THROW	__attribute__ ((__nothrow__ __LEAF))
 #  define __THROWNL	__attribute__ ((__nothrow__))
 #  define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct
 #  define __NTHNL(fct)  __attribute__ ((__nothrow__)) fct
 # else
-#  if defined __cplusplus && __GNUC_PREREQ (2,8)
-#   define __THROW	throw ()
-#   define __THROWNL	throw ()
-#   define __NTH(fct)	__LEAF_ATTR fct throw ()
-#   define __NTHNL(fct) fct throw ()
+#  if defined __cplusplus && (__GNUC_PREREQ (2,8) || __clang_major >= 4)
+#   if __cplusplus >= 201103L
+#    define __THROW	noexcept (true)
+#   else
+#    define __THROW	throw ()
+#   endif
+#   define __THROWNL	__THROW
+#   define __NTH(fct)	__LEAF_ATTR fct __THROW
+#   define __NTHNL(fct) fct __THROW
 #  else
 #   define __THROW
 #   define __THROWNL
@@ -70,7 +98,7 @@
 #  endif
 # endif
 
-#else	/* Not GCC.  */
+#else	/* Not GCC or clang.  */
 
 # if (defined __cplusplus						\
       || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
@@ -83,16 +111,7 @@
 # define __THROWNL
 # define __NTH(fct)	fct
 
-#endif	/* GCC.  */
-
-/* Compilers that are not clang may object to
-       #if defined __clang__ && __has_extension(...)
-   even though they do not need to evaluate the right-hand side of the &&.  */
-#if defined __clang__ && defined __has_extension
-# define __glibc_clang_has_extension(ext) __has_extension (ext)
-#else
-# define __glibc_clang_has_extension(ext) 0
-#endif
+#endif	/* GCC || clang.  */
 
 /* These two macros are not used in glibc anymore.  They are kept here
    only because some other projects expect the macros to be defined.  */
@@ -123,14 +142,70 @@
 #define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
 #define __bos0(ptr) __builtin_object_size (ptr, 0)
 
+/* Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.  */
+#if __USE_FORTIFY_LEVEL == 3 && (__glibc_clang_prereq (9, 0)		      \
+				 || __GNUC_PREREQ (12, 0))
+# define __glibc_objsize0(__o) __builtin_dynamic_object_size (__o, 0)
+# define __glibc_objsize(__o) __builtin_dynamic_object_size (__o, 1)
+#else
+# define __glibc_objsize0(__o) __bos0 (__o)
+# define __glibc_objsize(__o) __bos (__o)
+#endif
+
+#if __USE_FORTIFY_LEVEL > 0
+/* Compile time conditions to choose between the regular, _chk and _chk_warn
+   variants.  These conditions should get evaluated to constant and optimized
+   away.  */
+
+#define __glibc_safe_len_cond(__l, __s, __osz) ((__l) <= (__osz) / (__s))
+#define __glibc_unsigned_or_positive(__l) \
+  ((__typeof (__l)) 0 < (__typeof (__l)) -1				      \
+   || (__builtin_constant_p (__l) && (__l) > 0))
+
+/* Length is known to be safe at compile time if the __L * __S <= __OBJSZ
+   condition can be folded to a constant and if it is true, or unknown (-1) */
+#define __glibc_safe_or_unknown_len(__l, __s, __osz) \
+  ((__builtin_constant_p (__osz) && (__osz) == (__SIZE_TYPE__) -1)	      \
+   || (__glibc_unsigned_or_positive (__l)				      \
+       && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), \
+						       (__s), (__osz)))	      \
+       && __glibc_safe_len_cond ((__SIZE_TYPE__) (__l), (__s), (__osz))))
+
+/* Conversely, we know at compile time that the length is unsafe if the
+   __L * __S <= __OBJSZ condition can be folded to a constant and if it is
+   false.  */
+#define __glibc_unsafe_len(__l, __s, __osz) \
+  (__glibc_unsigned_or_positive (__l)					      \
+   && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l),     \
+						   __s, __osz))		      \
+   && !__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz))
+
+/* Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
+   declared.  */
+
+#define __glibc_fortify(f, __l, __s, __osz, ...) \
+  (__glibc_safe_or_unknown_len (__l, __s, __osz)			      \
+   ? __ ## f ## _alias (__VA_ARGS__)					      \
+   : (__glibc_unsafe_len (__l, __s, __osz)				      \
+      ? __ ## f ## _chk_warn (__VA_ARGS__, __osz)			      \
+      : __ ## f ## _chk (__VA_ARGS__, __osz)))
+
+/* Fortify function f, where object size argument passed to f is the number of
+   elements and not total size.  */
+
+#define __glibc_fortify_n(f, __l, __s, __osz, ...) \
+  (__glibc_safe_or_unknown_len (__l, __s, __osz)			      \
+   ? __ ## f ## _alias (__VA_ARGS__)					      \
+   : (__glibc_unsafe_len (__l, __s, __osz)				      \
+      ? __ ## f ## _chk_warn (__VA_ARGS__, (__osz) / (__s))		      \
+      : __ ## f ## _chk (__VA_ARGS__, (__osz) / (__s))))
+#endif
+
 #if __GNUC_PREREQ (4,3)
-# define __warndecl(name, msg) \
-  extern void name (void) __attribute__((__warning__ (msg)))
 # define __warnattr(msg) __attribute__((__warning__ (msg)))
 # define __errordecl(name, msg) \
   extern void name (void) __attribute__((__error__ (msg)))
 #else
-# define __warndecl(name, msg) extern void name (void)
 # define __warnattr(msg)
 # define __errordecl(name, msg) extern void name (void)
 #endif
@@ -142,8 +217,8 @@
 #if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L && !defined __HP_cc
 # define __flexarr	[]
 # define __glibc_c99_flexarr_available 1
-#elif __GNUC_PREREQ (2,97)
-/* GCC 2.97 supports C99 flexible array members as an extension,
+#elif __GNUC_PREREQ (2,97) || defined __clang__
+/* GCC 2.97 and clang support C99 flexible array members as an extension,
    even when in C89 mode or compiling C++ (any version).  */
 # define __flexarr	[]
 # define __glibc_c99_flexarr_available 1
@@ -169,7 +244,7 @@
    Example:
    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
 
-#if defined __GNUC__ && __GNUC__ >= 2
+#if (defined __GNUC__ && __GNUC__ >= 2) || (__clang_major__ >= 4)
 
 # define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
 # ifdef __cplusplus
@@ -194,17 +269,17 @@
 */
 #endif
 
-/* GCC has various useful declarations that can be made with the
-   `__attribute__' syntax.  All of the ways we use this do fine if
-   they are omitted for compilers that don't understand it. */
-#if !defined __GNUC__ || __GNUC__ < 2
+/* GCC and clang have various useful declarations that can be made with
+   the '__attribute__' syntax.  All of the ways we use this do fine if
+   they are omitted for compilers that don't understand it.  */
+#if !(defined __GNUC__ || defined __clang__)
 # define __attribute__(xyz)	/* Ignore */
 #endif
 
 /* At some point during the gcc 2.96 development the `malloc' attribute
    for functions was introduced.  We don't want to use it unconditionally
    (although this would be possible) since it generates warnings.  */
-#if __GNUC_PREREQ (2,96)
+#if __GNUC_PREREQ (2,96) || __glibc_has_attribute (__malloc__)
 # define __attribute_malloc__ __attribute__ ((__malloc__))
 #else
 # define __attribute_malloc__ /* Ignore */
@@ -219,26 +294,41 @@
 # define __attribute_alloc_size__(params) /* Ignore.  */
 #endif
 
+/* Tell the compiler which argument to an allocation function
+   indicates the alignment of the allocation.  */
+#if __GNUC_PREREQ (4, 9) || __glibc_has_attribute (__alloc_align__)
+# define __attribute_alloc_align__(param) \
+  __attribute__ ((__alloc_align__ param))
+#else
+# define __attribute_alloc_align__(param) /* Ignore.  */
+#endif
+
 /* At some point during the gcc 2.96 development the `pure' attribute
    for functions was introduced.  We don't want to use it unconditionally
    (although this would be possible) since it generates warnings.  */
-#if __GNUC_PREREQ (2,96)
+#if __GNUC_PREREQ (2,96) || __glibc_has_attribute (__pure__)
 # define __attribute_pure__ __attribute__ ((__pure__))
 #else
 # define __attribute_pure__ /* Ignore */
 #endif
 
 /* This declaration tells the compiler that the value is constant.  */
-#if __GNUC_PREREQ (2,5)
+#if __GNUC_PREREQ (2,5) || __glibc_has_attribute (__const__)
 # define __attribute_const__ __attribute__ ((__const__))
 #else
 # define __attribute_const__ /* Ignore */
 #endif
 
+#if __GNUC_PREREQ (2,7) || __glibc_has_attribute (__unused__)
+# define __attribute_maybe_unused__ __attribute__ ((__unused__))
+#else
+# define __attribute_maybe_unused__ /* Ignore */
+#endif
+
 /* At some point during the gcc 3.1 development the `used' attribute
    for functions was introduced.  We don't want to use it unconditionally
    (although this would be possible) since it generates warnings.  */
-#if __GNUC_PREREQ (3,1)
+#if __GNUC_PREREQ (3,1) || __glibc_has_attribute (__used__)
 # define __attribute_used__ __attribute__ ((__used__))
 # define __attribute_noinline__ __attribute__ ((__noinline__))
 #else
@@ -247,7 +337,7 @@
 #endif
 
 /* Since version 3.2, gcc allows marking deprecated functions.  */
-#if __GNUC_PREREQ (3,2)
+#if __GNUC_PREREQ (3,2) || __glibc_has_attribute (__deprecated__)
 # define __attribute_deprecated__ __attribute__ ((__deprecated__))
 #else
 # define __attribute_deprecated__ /* Ignore */
@@ -256,8 +346,8 @@
 /* Since version 4.5, gcc also allows one to specify the message printed
    when a deprecated function is used.  clang claims to be gcc 4.2, but
    may also support this feature.  */
-#if __GNUC_PREREQ (4,5) || \
-    __glibc_clang_has_extension (__attribute_deprecated_with_message__)
+#if __GNUC_PREREQ (4,5) \
+    || __glibc_has_extension (__attribute_deprecated_with_message__)
 # define __attribute_deprecated_msg__(msg) \
 	 __attribute__ ((__deprecated__ (msg)))
 #else
@@ -270,7 +360,7 @@
    If several `format_arg' attributes are given for the same function, in
    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
    all designated arguments are considered.  */
-#if __GNUC_PREREQ (2,8)
+#if __GNUC_PREREQ (2,8) || __glibc_has_attribute (__format_arg__)
 # define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
 #else
 # define __attribute_format_arg__(x) /* Ignore */
@@ -280,7 +370,7 @@
    attribute for functions was introduced.  We don't want to use it
    unconditionally (although this would be possible) since it
    generates warnings.  */
-#if __GNUC_PREREQ (2,97)
+#if __GNUC_PREREQ (2,97) || __glibc_has_attribute (__format__)
 # define __attribute_format_strfmon__(a,b) \
   __attribute__ ((__format__ (__strfmon__, a, b)))
 #else
@@ -288,19 +378,33 @@
 #endif
 
 /* The nonnull function attribute marks pointer parameters that
-   must not be NULL.  Do not define __nonnull if it is already defined,
-   for portability when this file is used in Gnulib.  */
+   must not be NULL.  This has the name __nonnull in glibc,
+   and __attribute_nonnull__ in files shared with Gnulib to avoid
+   collision with a different __nonnull in DragonFlyBSD 5.9.  */
+#ifndef __attribute_nonnull__
+# if __GNUC_PREREQ (3,3) || __glibc_has_attribute (__nonnull__)
+#  define __attribute_nonnull__(params) __attribute__ ((__nonnull__ params))
+# else
+#  define __attribute_nonnull__(params)
+# endif
+#endif
 #ifndef __nonnull
-# if __GNUC_PREREQ (3,3)
-#  define __nonnull(params) __attribute__ ((__nonnull__ params))
+# define __nonnull(params) __attribute_nonnull__ (params)
+#endif
+
+/* The returns_nonnull function attribute marks the return type of the function
+   as always being non-null.  */
+#ifndef __returns_nonnull
+# if __GNUC_PREREQ (4, 9) || __glibc_has_attribute (__returns_nonnull__)
+# define __returns_nonnull __attribute__ ((__returns_nonnull__))
 # else
-#  define __nonnull(params)
+# define __returns_nonnull
 # endif
 #endif
 
 /* If fortification mode, we warn about unused results of certain
    function calls which can lead to problems.  */
-#if __GNUC_PREREQ (3,4)
+#if __GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)
 # define __attribute_warn_unused_result__ \
    __attribute__ ((__warn_unused_result__))
 # if defined __USE_FORTIFY_LEVEL && __USE_FORTIFY_LEVEL > 0
@@ -314,7 +418,7 @@
 #endif
 
 /* Forces a function to be always inlined.  */
-#if __GNUC_PREREQ (3,2)
+#if __GNUC_PREREQ (3,2) || __glibc_has_attribute (__always_inline__)
 /* The Linux kernel defines __always_inline in stddef.h (283d7573), and
    it conflicts with this definition.  Therefore undefine it first to
    allow either header to be included first.  */
@@ -327,7 +431,7 @@
 
 /* Associate error messages with the source location of the call site rather
    than with the source location inside the function.  */
-#if __GNUC_PREREQ (4,3)
+#if __GNUC_PREREQ (4,3) || __glibc_has_attribute (__artificial__)
 # define __attribute_artificial__ __attribute__ ((__artificial__))
 #else
 # define __attribute_artificial__ /* Ignore */
@@ -370,12 +474,14 @@
    run in pedantic mode if the uses are carefully marked using the
    `__extension__' keyword.  But this is not generally available before
    version 2.8.  */
-#if !__GNUC_PREREQ (2,8)
+#if !(__GNUC_PREREQ (2,8) || defined __clang__)
 # define __extension__		/* Ignore */
 #endif
 
-/* __restrict is known in EGCS 1.2 and above. */
-#if !__GNUC_PREREQ (2,92)
+/* __restrict is known in EGCS 1.2 and above, and in clang.
+   It works also in C++ mode (outside of arrays), but only when spelled
+   as '__restrict', not 'restrict'.  */
+#if !(__GNUC_PREREQ (2,92) || __clang_major__ >= 3)
 # if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #  define __restrict	restrict
 # else
@@ -385,8 +491,9 @@
 
 /* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
      array_name[restrict]
-   GCC 3.1 supports this.  */
-#if __GNUC_PREREQ (3,1) && !defined __GNUG__
+   GCC 3.1 and clang support this.
+   This syntax is not usable in C++ mode.  */
+#if (__GNUC_PREREQ (3,1) || __clang_major__ >= 3) && !defined __cplusplus
 # define __restrict_arr	__restrict
 #else
 # ifdef __GNUC__
@@ -401,7 +508,7 @@
 # endif
 #endif
 
-#if __GNUC__ >= 3
+#if (__GNUC__ >= 3) || __glibc_has_builtin (__builtin_expect)
 # define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
 # define __glibc_likely(cond)	__builtin_expect ((cond), 1)
 #else
@@ -409,15 +516,10 @@
 # define __glibc_likely(cond)	(cond)
 #endif
 
-#ifdef __has_attribute
-# define __glibc_has_attribute(attr)	__has_attribute (attr)
-#else
-# define __glibc_has_attribute(attr)	0
-#endif
-
 #if (!defined _Noreturn \
      && (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112 \
-     &&  !__GNUC_PREREQ (4,7))
+     &&  !(__GNUC_PREREQ (4,7) \
+           || (3 < __clang_major__ + (5 <= __clang_minor__))))
 # if __GNUC_PREREQ (2,8)
 #  define _Noreturn __attribute__ ((__noreturn__))
 # else
@@ -434,22 +536,63 @@
 # define __attribute_nonstring__
 #endif
 
+/* Undefine (also defined in libc-symbols.h).  */
+#undef __attribute_copy__
+#if __GNUC_PREREQ (9, 0)
+/* Copies attributes from the declaration or type referenced by
+   the argument.  */
+# define __attribute_copy__(arg) __attribute__ ((__copy__ (arg)))
+#else
+# define __attribute_copy__(arg)
+#endif
+
 #if (!defined _Static_assert && !defined __cplusplus \
      && (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112 \
-     && (!__GNUC_PREREQ (4, 6) || defined __STRICT_ANSI__))
+     && (!(__GNUC_PREREQ (4, 6) || __clang_major__ >= 4) \
+         || defined __STRICT_ANSI__))
 # define _Static_assert(expr, diagnostic) \
     extern int (*__Static_assert_function (void)) \
       [!!sizeof (struct { int __error_if_negative: (expr) ? 2 : -1; })]
 #endif
 
-/* The #ifndef lets Gnulib avoid including these on non-glibc
-   platforms, where the includes typically do not exist.  */
-#ifndef __WORDSIZE
+/* Gnulib avoids including these, as they don't work on non-glibc or
+   older glibc platforms.  */
+#ifndef __GNULIB_CDEFS
 # include <bits/wordsize.h>
 # include <bits/long-double.h>
 #endif
 
-#if defined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH
+#if __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1
+# ifdef __REDIRECT
+
+/* Alias name defined automatically.  */
+#  define __LDBL_REDIR(name, proto) ... unused__ldbl_redir
+#  define __LDBL_REDIR_DECL(name) \
+  extern __typeof (name) name __asm (__ASMNAME ("__" #name "ieee128"));
+
+/* Alias name defined automatically, with leading underscores.  */
+#  define __LDBL_REDIR2_DECL(name) \
+  extern __typeof (__##name) __##name \
+    __asm (__ASMNAME ("__" #name "ieee128"));
+
+/* Alias name defined manually.  */
+#  define __LDBL_REDIR1(name, proto, alias) ... unused__ldbl_redir1
+#  define __LDBL_REDIR1_DECL(name, alias) \
+  extern __typeof (name) name __asm (__ASMNAME (#alias));
+
+#  define __LDBL_REDIR1_NTH(name, proto, alias) \
+  __REDIRECT_NTH (name, proto, alias)
+#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
+  __LDBL_REDIR1_NTH (name, proto, __##alias##ieee128)
+
+/* Unused.  */
+#  define __REDIRECT_LDBL(name, proto, alias) ... unused__redirect_ldbl
+#  define __LDBL_REDIR_NTH(name, proto) ... unused__ldbl_redir_nth
+
+# else
+_Static_assert (0, "IEEE 128-bits long double requires redirection on this platform");
+# endif
+#elif defined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH
 # define __LDBL_COMPAT 1
 # ifdef __REDIRECT
 #  define __LDBL_REDIR1(name, proto, alias) __REDIRECT (name, proto, alias)
@@ -458,6 +601,8 @@
 #  define __LDBL_REDIR1_NTH(name, proto, alias) __REDIRECT_NTH (name, proto, alias)
 #  define __LDBL_REDIR_NTH(name, proto) \
   __LDBL_REDIR1_NTH (name, proto, __nldbl_##name)
+#  define __LDBL_REDIR2_DECL(name) \
+  extern __typeof (__##name) __##name __asm (__ASMNAME ("__nldbl___" #name));
 #  define __LDBL_REDIR1_DECL(name, alias) \
   extern __typeof (name) name __asm (__ASMNAME (#alias));
 #  define __LDBL_REDIR_DECL(name) \
@@ -468,11 +613,13 @@
   __LDBL_REDIR1_NTH (name, proto, __nldbl_##alias)
 # endif
 #endif
-#if !defined __LDBL_COMPAT || !defined __REDIRECT
+#if (!defined __LDBL_COMPAT && __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 0) \
+    || !defined __REDIRECT
 # define __LDBL_REDIR1(name, proto, alias) name proto
 # define __LDBL_REDIR(name, proto) name proto
 # define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW
 # define __LDBL_REDIR_NTH(name, proto) name proto __THROW
+# define __LDBL_REDIR2_DECL(name)
 # define __LDBL_REDIR_DECL(name)
 # ifdef __REDIRECT
 #  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)
@@ -503,7 +650,7 @@
    check is required to enable the use of generic selection.  */
 #if !defined __cplusplus \
     && (__GNUC_PREREQ (4, 9) \
-	|| __glibc_clang_has_extension (c_generic_selections) \
+	|| __glibc_has_extension (c_generic_selections) \
 	|| (!defined __GNUC__ && defined __STDC_VERSION__ \
 	    && __STDC_VERSION__ >= 201112L))
 # define __HAVE_GENERIC_SELECTION 1
@@ -511,4 +658,50 @@
 # define __HAVE_GENERIC_SELECTION 0
 #endif
 
+#if __GNUC_PREREQ (10, 0)
+/* Designates a 1-based positional argument ref-index of pointer type
+   that can be used to access size-index elements of the pointed-to
+   array according to access mode, or at least one element when
+   size-index is not provided:
+     access (access-mode, <ref-index> [, <size-index>])  */
+#  define __attr_access(x) __attribute__ ((__access__ x))
+/* For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
+   use the access attribute to get object sizes from function definition
+   arguments, so we can't use them on functions we fortify.  Drop the object
+   size hints for such functions.  */
+#  if __USE_FORTIFY_LEVEL == 3
+#    define __fortified_attr_access(a, o, s) __attribute__ ((__access__ (a, o)))
+#  else
+#    define __fortified_attr_access(a, o, s) __attr_access ((a, o, s))
+#  endif
+#  if __GNUC_PREREQ (11, 0)
+#    define __attr_access_none(argno) __attribute__ ((__access__ (__none__, argno)))
+#  else
+#    define __attr_access_none(argno)
+#  endif
+#else
+#  define __fortified_attr_access(a, o, s)
+#  define __attr_access(x)
+#  define __attr_access_none(argno)
+#endif
+
+#if __GNUC_PREREQ (11, 0)
+/* Designates dealloc as a function to call to deallocate objects
+   allocated by the declared function.  */
+# define __attr_dealloc(dealloc, argno) \
+    __attribute__ ((__malloc__ (dealloc, argno)))
+# define __attr_dealloc_free __attr_dealloc (__builtin_free, 1)
+#else
+# define __attr_dealloc(dealloc, argno)
+# define __attr_dealloc_free
+#endif
+
+/* Specify that a function such as setjmp or vfork may return
+   twice.  */
+#if __GNUC_PREREQ (4, 1)
+# define __attribute_returns_twice__ __attribute__ ((__returns_twice__))
+#else
+# define __attribute_returns_twice__ /* Ignore.  */
+#endif
+
 #endif	 /* sys/cdefs.h */
--- gdb-10.2/gnulib/import/libc-config.h.orig
+++ gdb-10.2/gnulib/import/libc-config.h
@@ -79,13 +79,9 @@
 #ifndef _FEATURES_H
 # define _FEATURES_H 1
 #endif
-/* Define __WORDSIZE so that <cdefs.h> does not attempt to include
-   nonexistent files.  Make it a syntax error, since Gnulib does not
-   use __WORDSIZE now, and if Gnulib uses it later the syntax error
-   will let us know that __WORDSIZE needs configuring.  */
-#ifndef __WORDSIZE
-# define __WORDSIZE %%%
-#endif
+/* Define __GNULIB_CDEFS so that <cdefs.h> does not attempt to include
+   nonexistent files.  */
+# define __GNULIB_CDEFS
 /* Undef the macros unconditionally defined by our copy of glibc
    <sys/cdefs.h>, so that they do not clash with any system-defined
    versions.  */
--- gdb-10.2/libiberty/aclocal.m4.orig
+++ gdb-10.2/libiberty/aclocal.m4
@@ -16,6 +16,8 @@ AC_CACHE_CHECK([for working strncmp], ac
 [AC_TRY_RUN([
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -43,7 +45,8 @@ AC_CACHE_CHECK([for working strncmp], ac
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
@@ -149,7 +152,10 @@ if test $ac_cv_os_cray = yes; then
 fi
 
 AC_CACHE_CHECK(stack direction for C alloca, ac_cv_c_stack_direction,
-[AC_TRY_RUN([find_stack_direction ()
+[AC_TRY_RUN([#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -161,7 +167,9 @@ AC_CACHE_CHECK(stack direction for C all
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }], 
--- gdb-10.2/libiberty/configure.orig
+++ gdb-10.2/libiberty/configure
@@ -6724,7 +6724,10 @@ else
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-find_stack_direction ()
+#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -6736,7 +6739,9 @@ find_stack_direction ()
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }
@@ -7557,6 +7562,8 @@ else
 
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -7584,7 +7591,8 @@ else
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
--- gdb-10.2/readline/readline/aclocal.m4.orig
+++ gdb-10.2/readline/readline/aclocal.m4
@@ -10,6 +10,7 @@ AC_DEFUN(BASH_C_LONG_LONG,
   ac_cv_c_long_long=yes
 else
 AC_TRY_RUN([
+#include <stdlib.h>
 int
 main()
 {
@@ -33,6 +34,7 @@ AC_DEFUN(BASH_C_LONG_DOUBLE,
   ac_cv_c_long_double=yes
 else
 AC_TRY_RUN([
+#include <stdlib.h>
 int
 main()
 {
@@ -134,6 +136,8 @@ typedef int (*_bashfunc)(const char *, .
 #else
 typedef int (*_bashfunc)();
 #endif
+#include <stdlib.h>
+int
 main()
 {
 _bashfunc pf;
@@ -191,9 +195,11 @@ AC_CACHE_VAL(bash_cv_under_sys_siglist,
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <stdlib.h>
 #ifndef UNDER_SYS_SIGLIST_DECLARED
 extern char *_sys_siglist[];
 #endif
+int
 main()
 {
 char *msg = (char *)_sys_siglist[2];
@@ -218,9 +224,11 @@ AC_CACHE_VAL(bash_cv_sys_siglist,
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <stdlib.h>
 #if !HAVE_DECL_SYS_SIGLIST
 extern char *sys_siglist[];
 #endif
+int
 main()
 {
 char *msg = sys_siglist[2];
@@ -273,6 +281,8 @@ AC_CACHE_VAL(bash_cv_dup2_broken,
 [AC_TRY_RUN([
 #include <sys/types.h>
 #include <fcntl.h>
+#include <stdlib.h>
+int
 main()
 {
   int fd1, fd2, fl;
@@ -335,6 +345,8 @@ AC_CACHE_VAL(bash_cv_opendir_not_robust,
 #  include <ndir.h>
 # endif
 #endif /* HAVE_DIRENT_H */
+#include <stdlib.h>
+int
 main()
 {
 DIR *dir;
@@ -514,6 +526,8 @@ AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include <stdlib.h>
+int
 main()
 {
 #ifdef HAVE_QUAD_T
@@ -583,6 +597,7 @@ AC_CACHE_VAL(bash_cv_getenv_redef,
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
 #endif
+#include <stdlib.h>
 #ifndef __STDC__
 #  ifndef const
 #    define const
@@ -598,6 +613,7 @@ getenv (name)
 {
 return "42";
 }
+int
 main()
 {
 char *s;
@@ -786,7 +802,9 @@ AC_CACHE_VAL(bash_cv_func_sigsetjmp,
 #include <sys/types.h>
 #include <signal.h>
 #include <setjmp.h>
+#include <stdlib.h>
 
+int
 main()
 {
 #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
@@ -835,7 +853,10 @@ AC_CACHE_VAL(bash_cv_func_strcoll_broken
 #if defined (HAVE_LOCALE_H)
 #include <locale.h>
 #endif
+#include <string.h>
+#include <stdlib.h>
 
+int
 main(c, v)
 int     c;
 char    *v[];
@@ -881,6 +902,7 @@ AC_CACHE_VAL(bash_cv_printf_a_format,
 [AC_TRY_RUN([
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 
 int
 main()
@@ -1241,6 +1263,8 @@ AC_CACHE_VAL(bash_cv_pgrp_pipe,
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
 #endif
+#include <stdlib.h>
+int
 main()
 {
 # ifdef GETPGRP_VOID
@@ -1305,6 +1329,7 @@ AC_CACHE_VAL(bash_cv_must_reinstall_sigh
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <stdlib.h>
 
 typedef RETSIGTYPE sigfunc();
 
@@ -1335,6 +1360,7 @@ int s;
   nsigint++;
 }
 
+int
 main()
 {
 	nsigint = 0;
@@ -1418,8 +1444,11 @@ AC_CACHE_VAL(bash_cv_sys_named_pipes,
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <stdio.h>
+#include <stdlib.h>
 
 /* Add more tests in here as appropriate. */
+int
 main()
 {
 int fd, err;
@@ -1651,11 +1680,13 @@ AC_CACHE_VAL(bash_cv_unusable_rtsigs,
 [AC_TRY_RUN([
 #include <sys/types.h>
 #include <signal.h>
+#include <stdlib.h>
 
 #ifndef NSIG
 #  define NSIG 64
 #endif
 
+int
 main ()
 {
   int n_sigs = 2 * NSIG;
@@ -1770,6 +1801,7 @@ bash_cv_wcwidth_broken,
 #include <locale.h>
 #include <wchar.h>
 
+int
 main(c, v)
 int     c;
 char    **v;
@@ -1834,9 +1866,11 @@ AC_CACHE_VAL(ac_cv_rl_version,
 [AC_TRY_RUN([
 #include <stdio.h>
 #include <readline/readline.h>
+#include <stdlib.h>
 
 extern int rl_gnu_readline_p;
 
+int
 main()
 {
 	FILE *fp;
@@ -1926,7 +1960,9 @@ AC_CACHE_VAL(bash_cv_func_ctype_nonascii
 #endif
 #include <stdio.h>
 #include <ctype.h>
+#include <stdlib.h>
 
+int
 main(c, v)
 int	c;
 char	*v[];
@@ -4068,7 +4104,9 @@ AC_DEFUN([BASH_FUNC_SNPRINTF],
     AC_CACHE_CHECK([for standard-conformant snprintf], [bash_cv_func_snprintf],
       [AC_TRY_RUN([
 #include <stdio.h>
+#include <stdlib.h>
 
+int
 main()
 {
   int n;
@@ -4154,6 +4192,7 @@ AC_CACHE_VAL(bash_cv_wexitstatus_offset,
 
 #include <sys/wait.h>
 
+int
 main(c, v)
      int c;
      char **v;
--- gdb-10.2/readline/readline/configure.orig
+++ gdb-10.2/readline/readline/configure
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac for Readline 8.0, version 2.85.
+# From configure.ac for Readline 8.0, version 2.86.
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69 for readline 8.0.
 #
@@ -5316,6 +5316,7 @@ else
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <stdlib.h>
 
 typedef RETSIGTYPE sigfunc();
 
@@ -5346,7 +5347,8 @@ int s;
   nsigint++;
 }
 
-main()
+int
+main(void)
 {
 	nsigint = 0;
 	set_signal_handler(SIGINT, sigint);
@@ -5396,8 +5398,10 @@ else
 #include <sys/types.h>
 #include <signal.h>
 #include <setjmp.h>
+#include <stdlib.h>
 
-main()
+int
+main(void)
 {
 #if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
 exit (1);
@@ -5499,7 +5503,10 @@ else
 #if defined (HAVE_LOCALE_H)
 #include <locale.h>
 #endif
+#include <string.h>
+#include <stdlib.h>
 
+int
 main(c, v)
 int     c;
 char    *v[];
@@ -5569,7 +5576,9 @@ else
 #endif
 #include <stdio.h>
 #include <ctype.h>
+#include <stdlib.h>
 
+int
 main(c, v)
 int	c;
 char	*v[];
@@ -6713,6 +6722,7 @@ else
 #include <locale.h>
 #include <wchar.h>
 
+int
 main(c, v)
 int     c;
 char    **v;
--- gdb-10.2/readline/readline/configure.ac.orig
+++ gdb-10.2/readline/readline/configure.ac
@@ -5,7 +5,7 @@ dnl report bugs to chet@po.cwru.edu
 dnl
 dnl Process this file with autoconf to produce a configure script.
 
-# Copyright (C) 1987-2018 Free Software Foundation, Inc.
+# Copyright (C) 1987-2019 Free Software Foundation, Inc.
 
 #   This program is free software: you can redistribute it and/or modify
 #   it under the terms of the GNU General Public License as published by
@@ -20,7 +20,7 @@ dnl Process this file with autoconf to p
 #   You should have received a copy of the GNU General Public License
 #   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-AC_REVISION([for Readline 8.0, version 2.85])
+AC_REVISION([for Readline 8.0, version 2.86])
 
 m4_include([../../config/override.m4])
 
